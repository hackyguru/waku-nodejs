import { g as bytesToUtf8, T as Tags, L as Logger } from './index-BIW3qNYx.js';

/**
 * Function to sort peers by latency from lowest to highest
 * @param peerStore - The Libp2p PeerStore
 * @param peers - The list of peers to choose from
 * @returns Sorted array of peers by latency
 */
async function sortPeersByLatency(peerStore, peers) {
    if (peers.length === 0)
        return [];
    const results = await Promise.all(peers.map(async (peer) => {
        try {
            const pingBytes = (await peerStore.get(peer.id)).metadata.get("ping");
            if (!pingBytes)
                return { peer, ping: Infinity };
            const ping = Number(bytesToUtf8(pingBytes));
            return { peer, ping };
        }
        catch (error) {
            return { peer, ping: Infinity };
        }
    }));
    // filter out null values
    const validResults = results.filter((result) => result !== null);
    return validResults
        .sort((a, b) => a.ping - b.ping)
        .map((result) => result.peer);
}
/**
 * Returns the list of peers that supports the given protocol.
 */
async function getPeersForProtocol(peerStore, protocols) {
    const peers = [];
    await peerStore.forEach((peer) => {
        for (let i = 0; i < protocols.length; i++) {
            if (peer.protocols.includes(protocols[i])) {
                peers.push(peer);
                break;
            }
        }
    });
    return peers;
}

/**
 * Retrieves a list of peers based on the specified criteria:
 * 1. If numPeers is 0, return all peers
 * 2. Bootstrap peers are prioritized
 * 3. Non-bootstrap peers are randomly selected to fill up to numPeers
 *
 * @param peers - The list of peers to filter from.
 * @param numPeers - The total number of peers to retrieve. If 0, all peers are returned, irrespective of `maxBootstrapPeers`.
 * @param maxBootstrapPeers - The maximum number of bootstrap peers to retrieve.
 * @returns An array of peers based on the specified criteria.
 */
function filterPeersByDiscovery(peers, numPeers, maxBootstrapPeers) {
    // Collect the bootstrap peers up to the specified maximum
    let bootstrapPeers = peers
        .filter((peer) => peer.tags.has(Tags.BOOTSTRAP))
        .slice(0, maxBootstrapPeers);
    // If numPeers is less than the number of bootstrap peers, adjust the bootstrapPeers array
    if (numPeers > 0 && numPeers < bootstrapPeers.length) {
        bootstrapPeers = bootstrapPeers.slice(0, numPeers);
    }
    // Collect non-bootstrap peers
    const nonBootstrapPeers = peers.filter((peer) => !peer.tags.has(Tags.BOOTSTRAP));
    // If numPeers is 0, return all peers
    if (numPeers === 0) {
        return [...bootstrapPeers, ...nonBootstrapPeers];
    }
    // Initialize the list of selected peers with the bootstrap peers
    const selectedPeers = [...bootstrapPeers];
    // Fill up to numPeers with remaining random peers if needed
    while (selectedPeers.length < numPeers && nonBootstrapPeers.length > 0) {
        const randomIndex = Math.floor(Math.random() * nonBootstrapPeers.length);
        const randomPeer = nonBootstrapPeers.splice(randomIndex, 1)[0];
        selectedPeers.push(randomPeer);
    }
    return selectedPeers;
}

function selectOpenConnection(connections) {
    return connections
        .filter((c) => c.status === "open")
        .sort((left, right) => right.timeline.open - left.timeline.open)
        .at(0);
}

const STREAM_LOCK_KEY = "consumed";
class StreamManager {
    multicodec;
    getConnections;
    addEventListener;
    log;
    ongoingCreation = new Set();
    streamPool = new Map();
    constructor(multicodec, getConnections, addEventListener) {
        this.multicodec = multicodec;
        this.getConnections = getConnections;
        this.addEventListener = addEventListener;
        this.log = new Logger(`stream-manager:${multicodec}`);
        this.addEventListener("peer:update", this.handlePeerUpdateStreamPool);
    }
    async getStream(peer) {
        const peerId = peer.id.toString();
        const scheduledStream = this.streamPool.get(peerId);
        if (scheduledStream) {
            this.streamPool.delete(peerId);
            await scheduledStream;
        }
        let stream = this.getOpenStreamForCodec(peer.id);
        if (stream) {
            this.log.info(`Found existing stream peerId=${peer.id.toString()} multicodec=${this.multicodec}`);
            this.lockStream(peer.id.toString(), stream);
            return stream;
        }
        stream = await this.createStream(peer);
        this.lockStream(peer.id.toString(), stream);
        return stream;
    }
    async createStream(peer, retries = 0) {
        const connections = this.getConnections(peer.id);
        const connection = selectOpenConnection(connections);
        if (!connection) {
            throw new Error(`Failed to get a connection to the peer peerId=${peer.id.toString()} multicodec=${this.multicodec}`);
        }
        let lastError;
        let stream;
        for (let i = 0; i < retries + 1; i++) {
            try {
                this.log.info(`Attempting to create a stream for peerId=${peer.id.toString()} multicodec=${this.multicodec}`);
                stream = await connection.newStream(this.multicodec);
                this.log.info(`Created stream for peerId=${peer.id.toString()} multicodec=${this.multicodec}`);
                break;
            }
            catch (error) {
                lastError = error;
            }
        }
        if (!stream) {
            throw new Error(`Failed to create a new stream for ${peer.id.toString()} -- ` +
                lastError);
        }
        return stream;
    }
    async createStreamWithLock(peer) {
        const peerId = peer.id.toString();
        if (this.ongoingCreation.has(peerId)) {
            this.log.info(`Skipping creation of a stream due to lock for peerId=${peerId} multicodec=${this.multicodec}`);
            return;
        }
        try {
            this.ongoingCreation.add(peerId);
            await this.createStream(peer);
        }
        catch (error) {
            this.log.error(`Failed to createStreamWithLock:`, error);
        }
        finally {
            this.ongoingCreation.delete(peerId);
        }
        return;
    }
    handlePeerUpdateStreamPool = (evt) => {
        const { peer } = evt.detail;
        if (!peer.protocols.includes(this.multicodec)) {
            return;
        }
        const stream = this.getOpenStreamForCodec(peer.id);
        if (stream) {
            return;
        }
        this.scheduleNewStream(peer);
    };
    scheduleNewStream(peer) {
        this.log.info(`Scheduling creation of a stream for peerId=${peer.id.toString()} multicodec=${this.multicodec}`);
        // abandon previous attempt
        if (this.streamPool.has(peer.id.toString())) {
            this.streamPool.delete(peer.id.toString());
        }
        this.streamPool.set(peer.id.toString(), this.createStreamWithLock(peer));
    }
    getOpenStreamForCodec(peerId) {
        const connections = this.getConnections(peerId);
        const connection = selectOpenConnection(connections);
        if (!connection) {
            return;
        }
        const stream = connection.streams.find((s) => s.protocol === this.multicodec);
        if (!stream) {
            return;
        }
        const isStreamUnusable = ["done", "closed", "closing"].includes(stream.writeStatus || "");
        if (isStreamUnusable || this.isStreamLocked(stream)) {
            return;
        }
        return stream;
    }
    lockStream(peerId, stream) {
        this.log.info(`Locking stream for peerId:${peerId}\tstreamId:${stream.id}`);
        stream.metadata[STREAM_LOCK_KEY] = true;
    }
    isStreamLocked(stream) {
        return !!stream.metadata[STREAM_LOCK_KEY];
    }
}

/**
 * A class with predefined helpers, to be used as a base to implement Waku
 * Protocols.
 */
class BaseProtocol {
    multicodec;
    components;
    log;
    pubsubTopics;
    addLibp2pEventListener;
    removeLibp2pEventListener;
    streamManager;
    constructor(multicodec, components, log, pubsubTopics) {
        this.multicodec = multicodec;
        this.components = components;
        this.log = log;
        this.pubsubTopics = pubsubTopics;
        this.addLibp2pEventListener = components.events.addEventListener.bind(components.events);
        this.removeLibp2pEventListener = components.events.removeEventListener.bind(components.events);
        this.streamManager = new StreamManager(multicodec, components.connectionManager.getConnections.bind(components.connectionManager), this.addLibp2pEventListener);
    }
    async getStream(peer) {
        return this.streamManager.getStream(peer);
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * the class protocol. Waku may or may not be currently connected to these
     * peers.
     */
    async allPeers() {
        return getPeersForProtocol(this.components.peerStore, [this.multicodec]);
    }
    async connectedPeers() {
        const peers = await this.allPeers();
        return peers.filter((peer) => {
            const connections = this.components.connectionManager.getConnections(peer.id);
            return connections.length > 0;
        });
    }
    /**
     * Retrieves a list of connected peers that support the protocol. The list is sorted by latency.
     *
     * @param numPeers - The total number of peers to retrieve. If 0, all peers are returned.
     * @param maxBootstrapPeers - The maximum number of bootstrap peers to retrieve.
     * @returns A list of peers that support the protocol sorted by latency. By default, returns all peers available, including bootstrap.
     */
    async getPeers({ numPeers, maxBootstrapPeers } = {
        maxBootstrapPeers: 0,
        numPeers: 0
    }) {
        // Retrieve all connected peers that support the protocol & shard (if configured)
        const allAvailableConnectedPeers = await this.connectedPeers();
        // Filter the peers based on discovery & number of peers requested
        const filteredPeers = filterPeersByDiscovery(allAvailableConnectedPeers, numPeers, maxBootstrapPeers);
        // Sort the peers by latency
        const sortedFilteredPeers = await sortPeersByLatency(this.components.peerStore, filteredPeers);
        if (sortedFilteredPeers.length === 0) {
            this.log.warn("No peers found. Ensure you have a connection to the network.");
        }
        if (sortedFilteredPeers.length < numPeers) {
            this.log.warn(`Only ${sortedFilteredPeers.length} peers found. Requested ${numPeers}.`);
        }
        return sortedFilteredPeers;
    }
}

export { BaseProtocol as B, StreamManager as S };

import { a as allocUnsafe, f as fromString, b as alloc$1, e as concat, u as utf8ToBytes$1, L as Logger } from './index-BIW3qNYx.js';

/* eslint-disable no-fallthrough */
const N1 = Math.pow(2, 7);
const N2 = Math.pow(2, 14);
const N3 = Math.pow(2, 21);
const N4 = Math.pow(2, 28);
const N5 = Math.pow(2, 35);
const N6 = Math.pow(2, 42);
const N7 = Math.pow(2, 49);
/** Most significant bit of a byte */
const MSB = 0x80;
/** Rest of the bits in a byte */
const REST = 0x7f;
function encodingLength(value) {
    if (value < N1) {
        return 1;
    }
    if (value < N2) {
        return 2;
    }
    if (value < N3) {
        return 3;
    }
    if (value < N4) {
        return 4;
    }
    if (value < N5) {
        return 5;
    }
    if (value < N6) {
        return 6;
    }
    if (value < N7) {
        return 7;
    }
    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
        throw new RangeError('Could not encode varint');
    }
    return 8;
}
function encodeUint8Array(value, buf, offset = 0) {
    switch (encodingLength(value)) {
        case 8: {
            buf[offset++] = (value & 0xFF) | MSB;
            value /= 128;
        }
        case 7: {
            buf[offset++] = (value & 0xFF) | MSB;
            value /= 128;
        }
        case 6: {
            buf[offset++] = (value & 0xFF) | MSB;
            value /= 128;
        }
        case 5: {
            buf[offset++] = (value & 0xFF) | MSB;
            value /= 128;
        }
        case 4: {
            buf[offset++] = (value & 0xFF) | MSB;
            value >>>= 7;
        }
        case 3: {
            buf[offset++] = (value & 0xFF) | MSB;
            value >>>= 7;
        }
        case 2: {
            buf[offset++] = (value & 0xFF) | MSB;
            value >>>= 7;
        }
        case 1: {
            buf[offset++] = (value & 0xFF);
            value >>>= 7;
            break;
        }
        default: throw new Error('unreachable');
    }
    return buf;
}
function encodeUint8ArrayList(value, buf, offset = 0) {
    switch (encodingLength(value)) {
        case 8: {
            buf.set(offset++, (value & 0xFF) | MSB);
            value /= 128;
        }
        case 7: {
            buf.set(offset++, (value & 0xFF) | MSB);
            value /= 128;
        }
        case 6: {
            buf.set(offset++, (value & 0xFF) | MSB);
            value /= 128;
        }
        case 5: {
            buf.set(offset++, (value & 0xFF) | MSB);
            value /= 128;
        }
        case 4: {
            buf.set(offset++, (value & 0xFF) | MSB);
            value >>>= 7;
        }
        case 3: {
            buf.set(offset++, (value & 0xFF) | MSB);
            value >>>= 7;
        }
        case 2: {
            buf.set(offset++, (value & 0xFF) | MSB);
            value >>>= 7;
        }
        case 1: {
            buf.set(offset++, (value & 0xFF));
            value >>>= 7;
            break;
        }
        default: throw new Error('unreachable');
    }
    return buf;
}
function decodeUint8Array(buf, offset) {
    let b = buf[offset];
    let res = 0;
    res += b & REST;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 1];
    res += (b & REST) << 7;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 2];
    res += (b & REST) << 14;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 3];
    res += (b & REST) << 21;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 4];
    res += (b & REST) * N4;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 5];
    res += (b & REST) * N5;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 6];
    res += (b & REST) * N6;
    if (b < MSB) {
        return res;
    }
    b = buf[offset + 7];
    res += (b & REST) * N7;
    if (b < MSB) {
        return res;
    }
    throw new RangeError('Could not decode varint');
}
function decodeUint8ArrayList(buf, offset) {
    let b = buf.get(offset);
    let res = 0;
    res += b & REST;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 1);
    res += (b & REST) << 7;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 2);
    res += (b & REST) << 14;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 3);
    res += (b & REST) << 21;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 4);
    res += (b & REST) * N4;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 5);
    res += (b & REST) * N5;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 6);
    res += (b & REST) * N6;
    if (b < MSB) {
        return res;
    }
    b = buf.get(offset + 7);
    res += (b & REST) * N7;
    if (b < MSB) {
        return res;
    }
    throw new RangeError('Could not decode varint');
}
function encode(value, buf, offset = 0) {
    if (buf == null) {
        buf = allocUnsafe(encodingLength(value));
    }
    if (buf instanceof Uint8Array) {
        return encodeUint8Array(value, buf, offset);
    }
    else {
        return encodeUint8ArrayList(value, buf, offset);
    }
}
function decode(buf, offset = 0) {
    if (buf instanceof Uint8Array) {
        return decodeUint8Array(buf, offset);
    }
    else {
        return decodeUint8ArrayList(buf, offset);
    }
}

const f32 = new Float32Array([-0]);
const f8b = new Uint8Array(f32.buffer);
/**
 * Writes a 32 bit float to a buffer using little endian byte order
 */
function writeFloatLE(val, buf, pos) {
    f32[0] = val;
    buf[pos] = f8b[0];
    buf[pos + 1] = f8b[1];
    buf[pos + 2] = f8b[2];
    buf[pos + 3] = f8b[3];
}
/**
 * Reads a 32 bit float from a buffer using little endian byte order
 */
function readFloatLE(buf, pos) {
    f8b[0] = buf[pos];
    f8b[1] = buf[pos + 1];
    f8b[2] = buf[pos + 2];
    f8b[3] = buf[pos + 3];
    return f32[0];
}
const f64 = new Float64Array([-0]);
const d8b = new Uint8Array(f64.buffer);
/**
 * Writes a 64 bit double to a buffer using little endian byte order
 */
function writeDoubleLE(val, buf, pos) {
    f64[0] = val;
    buf[pos] = d8b[0];
    buf[pos + 1] = d8b[1];
    buf[pos + 2] = d8b[2];
    buf[pos + 3] = d8b[3];
    buf[pos + 4] = d8b[4];
    buf[pos + 5] = d8b[5];
    buf[pos + 6] = d8b[6];
    buf[pos + 7] = d8b[7];
}
/**
 * Reads a 64 bit double from a buffer using little endian byte order
 */
function readDoubleLE(buf, pos) {
    d8b[0] = buf[pos];
    d8b[1] = buf[pos + 1];
    d8b[2] = buf[pos + 2];
    d8b[3] = buf[pos + 3];
    d8b[4] = buf[pos + 4];
    d8b[5] = buf[pos + 5];
    d8b[6] = buf[pos + 6];
    d8b[7] = buf[pos + 7];
    return f64[0];
}

// the largest BigInt we can safely downcast to a Number
const MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
const MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);
/**
 * Constructs new long bits.
 *
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @function Object() { [native code] }
 * @param {number} lo - Low 32 bits, unsigned
 * @param {number} hi - High 32 bits, unsigned
 */
class LongBits {
    lo;
    hi;
    constructor(lo, hi) {
        // note that the casts below are theoretically unnecessary as of today, but older statically
        // generated converter code might still call the ctor with signed 32bits. kept for compat.
        /**
         * Low bits
         */
        this.lo = lo | 0;
        /**
         * High bits
         */
        this.hi = hi | 0;
    }
    /**
     * Converts this long bits to a possibly unsafe JavaScript number
     */
    toNumber(unsigned = false) {
        if (!unsigned && (this.hi >>> 31) > 0) {
            const lo = ~this.lo + 1 >>> 0;
            let hi = ~this.hi >>> 0;
            if (lo === 0) {
                hi = hi + 1 >>> 0;
            }
            return -(lo + hi * 4294967296);
        }
        return this.lo + this.hi * 4294967296;
    }
    /**
     * Converts this long bits to a bigint
     */
    toBigInt(unsigned = false) {
        if (unsigned) {
            return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
        }
        if ((this.hi >>> 31) !== 0) {
            const lo = ~this.lo + 1 >>> 0;
            let hi = ~this.hi >>> 0;
            if (lo === 0) {
                hi = hi + 1 >>> 0;
            }
            return -(BigInt(lo) + (BigInt(hi) << 32n));
        }
        return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    /**
     * Converts this long bits to a string
     */
    toString(unsigned = false) {
        return this.toBigInt(unsigned).toString();
    }
    /**
     * Zig-zag encodes this long bits
     */
    zzEncode() {
        const mask = this.hi >> 31;
        this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
        this.lo = (this.lo << 1 ^ mask) >>> 0;
        return this;
    }
    /**
     * Zig-zag decodes this long bits
     */
    zzDecode() {
        const mask = -(this.lo & 1);
        this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
        this.hi = (this.hi >>> 1 ^ mask) >>> 0;
        return this;
    }
    /**
     * Calculates the length of this longbits when encoded as a varint.
     */
    length() {
        const part0 = this.lo;
        const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0;
        const part2 = this.hi >>> 24;
        return part2 === 0
            ? part1 === 0
                ? part0 < 16384
                    ? part0 < 128 ? 1 : 2
                    : part0 < 2097152 ? 3 : 4
                : part1 < 16384
                    ? part1 < 128 ? 5 : 6
                    : part1 < 2097152 ? 7 : 8
            : part2 < 128 ? 9 : 10;
    }
    /**
     * Constructs new long bits from the specified number
     */
    static fromBigInt(value) {
        if (value === 0n) {
            return zero;
        }
        if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {
            return this.fromNumber(Number(value));
        }
        const negative = value < 0n;
        if (negative) {
            value = -value;
        }
        let hi = value >> 32n;
        let lo = value - (hi << 32n);
        if (negative) {
            hi = ~hi | 0n;
            lo = ~lo | 0n;
            if (++lo > TWO_32) {
                lo = 0n;
                if (++hi > TWO_32) {
                    hi = 0n;
                }
            }
        }
        return new LongBits(Number(lo), Number(hi));
    }
    /**
     * Constructs new long bits from the specified number
     */
    static fromNumber(value) {
        if (value === 0) {
            return zero;
        }
        const sign = value < 0;
        if (sign) {
            value = -value;
        }
        let lo = value >>> 0;
        let hi = (value - lo) / 4294967296 >>> 0;
        if (sign) {
            hi = ~hi >>> 0;
            lo = ~lo >>> 0;
            if (++lo > 4294967295) {
                lo = 0;
                if (++hi > 4294967295) {
                    hi = 0;
                }
            }
        }
        return new LongBits(lo, hi);
    }
    /**
     * Constructs new long bits from a number, long or string
     */
    static from(value) {
        if (typeof value === 'number') {
            return LongBits.fromNumber(value);
        }
        if (typeof value === 'bigint') {
            return LongBits.fromBigInt(value);
        }
        if (typeof value === 'string') {
            return LongBits.fromBigInt(BigInt(value));
        }
        return value.low != null || value.high != null ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    }
}
const zero = new LongBits(0, 0);
zero.toBigInt = function () { return 0n; };
zero.zzEncode = zero.zzDecode = function () { return this; };
zero.length = function () { return 1; };
const TWO_32 = 4294967296n;

/**
 * Calculates the UTF8 byte length of a string
 */
function length(string) {
    let len = 0;
    let c = 0;
    for (let i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128) {
            len += 1;
        }
        else if (c < 2048) {
            len += 2;
        }
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        }
        else {
            len += 3;
        }
    }
    return len;
}
/**
 * Reads UTF8 bytes as a string
 */
function read(buffer, start, end) {
    const len = end - start;
    if (len < 1) {
        return '';
    }
    let parts;
    const chunk = [];
    let i = 0; // char offset
    let t; // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128) {
            chunk[i++] = t;
        }
        else if (t > 191 && t < 224) {
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        }
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        }
        else {
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        }
        if (i > 8191) {
            (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts != null) {
        if (i > 0) {
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        }
        return parts.join('');
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
}
/**
 * Writes a string as UTF8 bytes
 */
function write(string, buffer, offset) {
    const start = offset;
    let c1; // character 1
    let c2; // character 2
    for (let i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        }
        else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6 | 192;
            buffer[offset++] = c1 & 63 | 128;
        }
        else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18 | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        }
        else {
            buffer[offset++] = c1 >> 12 | 224;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        }
    }
    return offset - start;
}

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`);
}
function readFixed32End(buf, end) {
    return (buf[end - 4] |
        buf[end - 3] << 8 |
        buf[end - 2] << 16 |
        buf[end - 1] << 24) >>> 0;
}
/**
 * Constructs a new reader instance using the specified buffer.
 */
class Uint8ArrayReader {
    buf;
    pos;
    len;
    _slice = Uint8Array.prototype.subarray;
    constructor(buffer) {
        /**
         * Read buffer
         */
        this.buf = buffer;
        /**
         * Read buffer position
         */
        this.pos = 0;
        /**
         * Read buffer length
         */
        this.len = buffer.length;
    }
    /**
     * Reads a varint as an unsigned 32 bit value
     */
    uint32() {
        let value = 4294967295;
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
            return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
            return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
            return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
            return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
            return value;
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    }
    /**
     * Reads a varint as a signed 32 bit value
     */
    int32() {
        return this.uint32() | 0;
    }
    /**
     * Reads a zig-zag encoded varint as a signed 32 bit value
     */
    sint32() {
        const value = this.uint32();
        return value >>> 1 ^ -(value & 1) | 0;
    }
    /**
     * Reads a varint as a boolean
     */
    bool() {
        return this.uint32() !== 0;
    }
    /**
     * Reads fixed 32 bits as an unsigned 32 bit integer
     */
    fixed32() {
        if (this.pos + 4 > this.len) {
            throw indexOutOfRange(this, 4);
        }
        const res = readFixed32End(this.buf, this.pos += 4);
        return res;
    }
    /**
     * Reads fixed 32 bits as a signed 32 bit integer
     */
    sfixed32() {
        if (this.pos + 4 > this.len) {
            throw indexOutOfRange(this, 4);
        }
        const res = readFixed32End(this.buf, this.pos += 4) | 0;
        return res;
    }
    /**
     * Reads a float (32 bit) as a number
     */
    float() {
        if (this.pos + 4 > this.len) {
            throw indexOutOfRange(this, 4);
        }
        const value = readFloatLE(this.buf, this.pos);
        this.pos += 4;
        return value;
    }
    /**
     * Reads a double (64 bit float) as a number
     */
    double() {
        /* istanbul ignore if */
        if (this.pos + 8 > this.len) {
            throw indexOutOfRange(this, 4);
        }
        const value = readDoubleLE(this.buf, this.pos);
        this.pos += 8;
        return value;
    }
    /**
     * Reads a sequence of bytes preceded by its length as a varint
     */
    bytes() {
        const length = this.uint32();
        const start = this.pos;
        const end = this.pos + length;
        /* istanbul ignore if */
        if (end > this.len) {
            throw indexOutOfRange(this, length);
        }
        this.pos += length;
        return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
            ? new Uint8Array(0)
            : this.buf.subarray(start, end);
    }
    /**
     * Reads a string preceded by its byte length as a varint
     */
    string() {
        const bytes = this.bytes();
        return read(bytes, 0, bytes.length);
    }
    /**
     * Skips the specified number of bytes if specified, otherwise skips a varint
     */
    skip(length) {
        if (typeof length === 'number') {
            /* istanbul ignore if */
            if (this.pos + length > this.len) {
                throw indexOutOfRange(this, length);
            }
            this.pos += length;
        }
        else {
            do {
                /* istanbul ignore if */
                if (this.pos >= this.len) {
                    throw indexOutOfRange(this);
                }
            } while ((this.buf[this.pos++] & 128) !== 0);
        }
        return this;
    }
    /**
     * Skips the next element of the specified wire type
     */
    skipType(wireType) {
        switch (wireType) {
            case 0:
                this.skip();
                break;
            case 1:
                this.skip(8);
                break;
            case 2:
                this.skip(this.uint32());
                break;
            case 3:
                while ((wireType = this.uint32() & 7) !== 4) {
                    this.skipType(wireType);
                }
                break;
            case 5:
                this.skip(4);
                break;
            /* istanbul ignore next */
            default:
                throw Error(`invalid wire type ${wireType} at offset ${this.pos}`);
        }
        return this;
    }
    readLongVarint() {
        // tends to deopt with local vars for octet etc.
        const bits = new LongBits(0, 0);
        let i = 0;
        if (this.len - this.pos > 4) { // fast route (lo)
            for (; i < 4; ++i) {
                // 1st..4th
                bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
                if (this.buf[this.pos++] < 128) {
                    return bits;
                }
            }
            // 5th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
            if (this.buf[this.pos++] < 128) {
                return bits;
            }
            i = 0;
        }
        else {
            for (; i < 3; ++i) {
                /* istanbul ignore if */
                if (this.pos >= this.len) {
                    throw indexOutOfRange(this);
                }
                // 1st..3th
                bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
                if (this.buf[this.pos++] < 128) {
                    return bits;
                }
            }
            // 4th
            bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
            return bits;
        }
        if (this.len - this.pos > 4) { // fast route (hi)
            for (; i < 5; ++i) {
                // 6th..10th
                bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
                if (this.buf[this.pos++] < 128) {
                    return bits;
                }
            }
        }
        else {
            for (; i < 5; ++i) {
                if (this.pos >= this.len) {
                    throw indexOutOfRange(this);
                }
                // 6th..10th
                bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
                if (this.buf[this.pos++] < 128) {
                    return bits;
                }
            }
        }
        throw Error('invalid varint encoding');
    }
    readFixed64() {
        if (this.pos + 8 > this.len) {
            throw indexOutOfRange(this, 8);
        }
        const lo = readFixed32End(this.buf, this.pos += 4);
        const hi = readFixed32End(this.buf, this.pos += 4);
        return new LongBits(lo, hi);
    }
    /**
     * Reads a varint as a signed 64 bit value
     */
    int64() {
        return this.readLongVarint().toBigInt();
    }
    /**
     * Reads a varint as a signed 64 bit value returned as a possibly unsafe
     * JavaScript number
     */
    int64Number() {
        return this.readLongVarint().toNumber();
    }
    /**
     * Reads a varint as a signed 64 bit value returned as a string
     */
    int64String() {
        return this.readLongVarint().toString();
    }
    /**
     * Reads a varint as an unsigned 64 bit value
     */
    uint64() {
        return this.readLongVarint().toBigInt(true);
    }
    /**
     * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe
     * JavaScript number
     */
    uint64Number() {
        const value = decodeUint8Array(this.buf, this.pos);
        this.pos += encodingLength(value);
        return value;
    }
    /**
     * Reads a varint as an unsigned 64 bit value returned as a string
     */
    uint64String() {
        return this.readLongVarint().toString(true);
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value
     */
    sint64() {
        return this.readLongVarint().zzDecode().toBigInt();
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
     * possibly unsafe JavaScript number
     */
    sint64Number() {
        return this.readLongVarint().zzDecode().toNumber();
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
     * string
     */
    sint64String() {
        return this.readLongVarint().zzDecode().toString();
    }
    /**
     * Reads fixed 64 bits
     */
    fixed64() {
        return this.readFixed64().toBigInt();
    }
    /**
     * Reads fixed 64 bits returned as a possibly unsafe JavaScript number
     */
    fixed64Number() {
        return this.readFixed64().toNumber();
    }
    /**
     * Reads fixed 64 bits returned as a string
     */
    fixed64String() {
        return this.readFixed64().toString();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits
     */
    sfixed64() {
        return this.readFixed64().toBigInt();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe
     * JavaScript number
     */
    sfixed64Number() {
        return this.readFixed64().toNumber();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits returned as a string
     */
    sfixed64String() {
        return this.readFixed64().toString();
    }
}
function createReader(buf) {
    return new Uint8ArrayReader(buf instanceof Uint8Array ? buf : buf.subarray());
}

function decodeMessage(buf, codec, opts) {
    const reader = createReader(buf);
    return codec.decode(reader, undefined, opts);
}

/**
 * A general purpose buffer pool
 */
function pool(size) {
    const SIZE = 8192;
    const MAX = SIZE >>> 1;
    let slab;
    let offset = SIZE;
    return function poolAlloc(size) {
        if (size < 1 || size > MAX) {
            return allocUnsafe(size);
        }
        if (offset + size > SIZE) {
            slab = allocUnsafe(SIZE);
            offset = 0;
        }
        const buf = slab.subarray(offset, offset += size);
        if ((offset & 7) !== 0) {
            // align to 32 bit
            offset = (offset | 7) + 1;
        }
        return buf;
    };
}

/**
 * Constructs a new writer operation instance.
 *
 * @classdesc Scheduled writer operation
 */
class Op {
    /**
     * Function to call
     */
    fn;
    /**
     * Value byte length
     */
    len;
    /**
     * Next operation
     */
    next;
    /**
     * Value to write
     */
    val;
    constructor(fn, len, val) {
        this.fn = fn;
        this.len = len;
        this.next = undefined;
        this.val = val; // type varies
    }
}
/* istanbul ignore next */
function noop() { } // eslint-disable-line no-empty-function
/**
 * Constructs a new writer state instance
 */
class State {
    /**
     * Current head
     */
    head;
    /**
     * Current tail
     */
    tail;
    /**
     * Current buffer length
     */
    len;
    /**
     * Next state
     */
    next;
    constructor(writer) {
        this.head = writer.head;
        this.tail = writer.tail;
        this.len = writer.len;
        this.next = writer.states;
    }
}
const bufferPool = pool();
/**
 * Allocates a buffer of the specified size
 */
function alloc(size) {
    if (globalThis.Buffer != null) {
        return allocUnsafe(size);
    }
    return bufferPool(size);
}
/**
 * When a value is written, the writer calculates its byte length and puts it into a linked
 * list of operations to perform when finish() is called. This both allows us to allocate
 * buffers of the exact required size and reduces the amount of work we have to do compared
 * to first calculating over objects and then encoding over objects. In our case, the encoding
 * part is just a linked list walk calling operations with already prepared values.
 */
class Uint8ArrayWriter {
    /**
     * Current length
     */
    len;
    /**
     * Operations head
     */
    head;
    /**
     * Operations tail
     */
    tail;
    /**
     * Linked forked states
     */
    states;
    constructor() {
        this.len = 0;
        this.head = new Op(noop, 0, 0);
        this.tail = this.head;
        this.states = null;
    }
    /**
     * Pushes a new operation to the queue
     */
    _push(fn, len, val) {
        this.tail = this.tail.next = new Op(fn, len, val);
        this.len += len;
        return this;
    }
    /**
     * Writes an unsigned 32 bit value as a varint
     */
    uint32(value) {
        // here, the call to this.push has been inlined and a varint specific Op subclass is used.
        // uint32 is by far the most frequently used operation and benefits significantly from this.
        this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) <
            128
            ? 1
            : value < 16384
                ? 2
                : value < 2097152
                    ? 3
                    : value < 268435456
                        ? 4
                        : 5, value)).len;
        return this;
    }
    /**
     * Writes a signed 32 bit value as a varint`
     */
    int32(value) {
        return value < 0
            ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
            : this.uint32(value);
    }
    /**
     * Writes a 32 bit value as a varint, zig-zag encoded
     */
    sint32(value) {
        return this.uint32((value << 1 ^ value >> 31) >>> 0);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */
    uint64(value) {
        const bits = LongBits.fromBigInt(value);
        return this._push(writeVarint64, bits.length(), bits);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */
    uint64Number(value) {
        return this._push(encodeUint8Array, encodingLength(value), value);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */
    uint64String(value) {
        return this.uint64(BigInt(value));
    }
    /**
     * Writes a signed 64 bit value as a varint
     */
    int64(value) {
        return this.uint64(value);
    }
    /**
     * Writes a signed 64 bit value as a varint
     */
    int64Number(value) {
        return this.uint64Number(value);
    }
    /**
     * Writes a signed 64 bit value as a varint
     */
    int64String(value) {
        return this.uint64String(value);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */
    sint64(value) {
        const bits = LongBits.fromBigInt(value).zzEncode();
        return this._push(writeVarint64, bits.length(), bits);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */
    sint64Number(value) {
        const bits = LongBits.fromNumber(value).zzEncode();
        return this._push(writeVarint64, bits.length(), bits);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */
    sint64String(value) {
        return this.sint64(BigInt(value));
    }
    /**
     * Writes a boolish value as a varint
     */
    bool(value) {
        return this._push(writeByte, 1, value ? 1 : 0);
    }
    /**
     * Writes an unsigned 32 bit value as fixed 32 bits
     */
    fixed32(value) {
        return this._push(writeFixed32, 4, value >>> 0);
    }
    /**
     * Writes a signed 32 bit value as fixed 32 bits
     */
    sfixed32(value) {
        return this.fixed32(value);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */
    fixed64(value) {
        const bits = LongBits.fromBigInt(value);
        return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */
    fixed64Number(value) {
        const bits = LongBits.fromNumber(value);
        return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */
    fixed64String(value) {
        return this.fixed64(BigInt(value));
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */
    sfixed64(value) {
        return this.fixed64(value);
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */
    sfixed64Number(value) {
        return this.fixed64Number(value);
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */
    sfixed64String(value) {
        return this.fixed64String(value);
    }
    /**
     * Writes a float (32 bit)
     */
    float(value) {
        return this._push(writeFloatLE, 4, value);
    }
    /**
     * Writes a double (64 bit float).
     *
     * @function
     * @param {number} value - Value to write
     * @returns {Writer} `this`
     */
    double(value) {
        return this._push(writeDoubleLE, 8, value);
    }
    /**
     * Writes a sequence of bytes
     */
    bytes(value) {
        const len = value.length >>> 0;
        if (len === 0) {
            return this._push(writeByte, 1, 0);
        }
        return this.uint32(len)._push(writeBytes, len, value);
    }
    /**
     * Writes a string
     */
    string(value) {
        const len = length(value);
        return len !== 0
            ? this.uint32(len)._push(write, len, value)
            : this._push(writeByte, 1, 0);
    }
    /**
     * Forks this writer's state by pushing it to a stack.
     * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
     */
    fork() {
        this.states = new State(this);
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
        return this;
    }
    /**
     * Resets this instance to the last state
     */
    reset() {
        if (this.states != null) {
            this.head = this.states.head;
            this.tail = this.states.tail;
            this.len = this.states.len;
            this.states = this.states.next;
        }
        else {
            this.head = this.tail = new Op(noop, 0, 0);
            this.len = 0;
        }
        return this;
    }
    /**
     * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
     */
    ldelim() {
        const head = this.head;
        const tail = this.tail;
        const len = this.len;
        this.reset().uint32(len);
        if (len !== 0) {
            this.tail.next = head.next; // skip noop
            this.tail = tail;
            this.len += len;
        }
        return this;
    }
    /**
     * Finishes the write operation
     */
    finish() {
        let head = this.head.next; // skip noop
        const buf = alloc(this.len);
        let pos = 0;
        while (head != null) {
            head.fn(head.val, buf, pos);
            pos += head.len;
            head = head.next;
        }
        // this.head = this.tail = null;
        return buf;
    }
}
function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}
function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}
/**
 * Constructs a new varint writer operation instance.
 *
 * @classdesc Scheduled varint writer operation
 */
class VarintOp extends Op {
    next;
    constructor(len, val) {
        super(writeVarint32, len, val);
        this.next = undefined;
    }
}
function writeVarint64(val, buf, pos) {
    while (val.hi !== 0) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}
function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
}
function writeBytes(val, buf, pos) {
    buf.set(val, pos);
}
if (globalThis.Buffer != null) {
    Uint8ArrayWriter.prototype.bytes = function (value) {
        const len = value.length >>> 0;
        this.uint32(len);
        if (len > 0) {
            this._push(writeBytesBuffer, len, value);
        }
        return this;
    };
    Uint8ArrayWriter.prototype.string = function (value) {
        const len = globalThis.Buffer.byteLength(value);
        this.uint32(len);
        if (len > 0) {
            this._push(writeStringBuffer, len, value);
        }
        return this;
    };
}
function writeBytesBuffer(val, buf, pos) {
    buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
    // also works for plain array values
}
function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) {
        // plain js is faster for short strings (probably due to redundant assertions)
        write(val, buf, pos);
        // @ts-expect-error buf isn't a Uint8Array?
    }
    else if (buf.utf8Write != null) {
        // @ts-expect-error buf isn't a Uint8Array?
        buf.utf8Write(val, pos);
    }
    else {
        buf.set(fromString(val), pos);
    }
}
/**
 * Creates a new writer
 */
function createWriter() {
    return new Uint8ArrayWriter();
}

function encodeMessage(message, codec) {
    const w = createWriter();
    codec.encode(message, w, {
        lengthDelimited: false
    });
    return w.finish();
}

// https://developers.google.com/protocol-buffers/docs/encoding#structure
var CODEC_TYPES;
(function (CODEC_TYPES) {
    CODEC_TYPES[CODEC_TYPES["VARINT"] = 0] = "VARINT";
    CODEC_TYPES[CODEC_TYPES["BIT64"] = 1] = "BIT64";
    CODEC_TYPES[CODEC_TYPES["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
    CODEC_TYPES[CODEC_TYPES["START_GROUP"] = 3] = "START_GROUP";
    CODEC_TYPES[CODEC_TYPES["END_GROUP"] = 4] = "END_GROUP";
    CODEC_TYPES[CODEC_TYPES["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES || (CODEC_TYPES = {}));
function createCodec(name, type, encode, decode) {
    return {
        name,
        type,
        encode,
        decode
    };
}

function enumeration(v) {
    function findValue(val) {
        // Use the reverse mapping to look up the enum key for the stored value
        // https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings
        if (v[val.toString()] == null) {
            throw new Error('Invalid enum value');
        }
        return v[val];
    }
    const encode = function enumEncode(val, writer) {
        const enumValue = findValue(val);
        writer.int32(enumValue);
    };
    const decode = function enumDecode(reader) {
        const val = reader.int32();
        return findValue(val);
    };
    // @ts-expect-error yeah yeah
    return createCodec('enum', CODEC_TYPES.VARINT, encode, decode);
}

function message$1(encode, decode) {
    return createCodec('message', CODEC_TYPES.LENGTH_DELIMITED, encode, decode);
}

/**
 * @packageDocumentation
 *
 * This module contains serialization/deserialization code used when encoding/decoding protobufs.
 *
 * It should be declared as a dependency of your project:
 *
 * ```console
 * npm i protons-runtime
 * ```
 */
/**
 * Thrown when a repeated field has too many elements
 */
class MaxLengthError extends Error {
    /**
     * This will be removed in a future release
     *
     * @deprecated use the `.name` property instead
     */
    code = 'ERR_MAX_LENGTH';
    name = 'MaxLengthError';
}

/* eslint-disable import/export */
/* eslint-disable complexity */
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */
/* eslint-disable @typescript-eslint/no-empty-interface */
var RateLimitProof$4;
(function (RateLimitProof) {
    let _codec;
    RateLimitProof.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.proof != null && obj.proof.byteLength > 0)) {
                    w.uint32(10);
                    w.bytes(obj.proof);
                }
                if ((obj.merkleRoot != null && obj.merkleRoot.byteLength > 0)) {
                    w.uint32(18);
                    w.bytes(obj.merkleRoot);
                }
                if ((obj.epoch != null && obj.epoch.byteLength > 0)) {
                    w.uint32(26);
                    w.bytes(obj.epoch);
                }
                if ((obj.shareX != null && obj.shareX.byteLength > 0)) {
                    w.uint32(34);
                    w.bytes(obj.shareX);
                }
                if ((obj.shareY != null && obj.shareY.byteLength > 0)) {
                    w.uint32(42);
                    w.bytes(obj.shareY);
                }
                if ((obj.nullifier != null && obj.nullifier.byteLength > 0)) {
                    w.uint32(50);
                    w.bytes(obj.nullifier);
                }
                if ((obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0)) {
                    w.uint32(58);
                    w.bytes(obj.rlnIdentifier);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    proof: alloc$1(0),
                    merkleRoot: alloc$1(0),
                    epoch: alloc$1(0),
                    shareX: alloc$1(0),
                    shareY: alloc$1(0),
                    nullifier: alloc$1(0),
                    rlnIdentifier: alloc$1(0)
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.proof = reader.bytes();
                            break;
                        }
                        case 2: {
                            obj.merkleRoot = reader.bytes();
                            break;
                        }
                        case 3: {
                            obj.epoch = reader.bytes();
                            break;
                        }
                        case 4: {
                            obj.shareX = reader.bytes();
                            break;
                        }
                        case 5: {
                            obj.shareY = reader.bytes();
                            break;
                        }
                        case 6: {
                            obj.nullifier = reader.bytes();
                            break;
                        }
                        case 7: {
                            obj.rlnIdentifier = reader.bytes();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    RateLimitProof.encode = (obj) => {
        return encodeMessage(obj, RateLimitProof.codec());
    };
    RateLimitProof.decode = (buf, opts) => {
        return decodeMessage(buf, RateLimitProof.codec(), opts);
    };
})(RateLimitProof$4 || (RateLimitProof$4 = {}));
var WakuMessage$4;
(function (WakuMessage) {
    let _codec;
    WakuMessage.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.payload != null && obj.payload.byteLength > 0)) {
                    w.uint32(10);
                    w.bytes(obj.payload);
                }
                if ((obj.contentTopic != null && obj.contentTopic !== '')) {
                    w.uint32(18);
                    w.string(obj.contentTopic);
                }
                if (obj.version != null) {
                    w.uint32(24);
                    w.uint32(obj.version);
                }
                if (obj.timestamp != null) {
                    w.uint32(80);
                    w.sint64(obj.timestamp);
                }
                if (obj.meta != null) {
                    w.uint32(90);
                    w.bytes(obj.meta);
                }
                if (obj.rateLimitProof != null) {
                    w.uint32(170);
                    RateLimitProof$4.codec().encode(obj.rateLimitProof, w);
                }
                if (obj.ephemeral != null) {
                    w.uint32(248);
                    w.bool(obj.ephemeral);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    payload: alloc$1(0),
                    contentTopic: ''
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.payload = reader.bytes();
                            break;
                        }
                        case 2: {
                            obj.contentTopic = reader.string();
                            break;
                        }
                        case 3: {
                            obj.version = reader.uint32();
                            break;
                        }
                        case 10: {
                            obj.timestamp = reader.sint64();
                            break;
                        }
                        case 11: {
                            obj.meta = reader.bytes();
                            break;
                        }
                        case 21: {
                            obj.rateLimitProof = RateLimitProof$4.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.rateLimitProof
                            });
                            break;
                        }
                        case 31: {
                            obj.ephemeral = reader.bool();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    WakuMessage.encode = (obj) => {
        return encodeMessage(obj, WakuMessage.codec());
    };
    WakuMessage.decode = (buf, opts) => {
        return decodeMessage(buf, WakuMessage.codec(), opts);
    };
})(WakuMessage$4 || (WakuMessage$4 = {}));

var message = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get RateLimitProof () { return RateLimitProof$4; },
    get WakuMessage () { return WakuMessage$4; }
});

/* eslint-disable import/export */
/* eslint-disable complexity */
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */
/* eslint-disable @typescript-eslint/no-empty-interface */
var FilterRequest;
(function (FilterRequest) {
    (function (ContentFilter) {
        let _codec;
        ContentFilter.codec = () => {
            if (_codec == null) {
                _codec = message$1((obj, w, opts = {}) => {
                    if (opts.lengthDelimited !== false) {
                        w.fork();
                    }
                    if ((obj.contentTopic != null && obj.contentTopic !== '')) {
                        w.uint32(10);
                        w.string(obj.contentTopic);
                    }
                    if (opts.lengthDelimited !== false) {
                        w.ldelim();
                    }
                }, (reader, length, opts = {}) => {
                    const obj = {
                        contentTopic: ''
                    };
                    const end = length == null ? reader.len : reader.pos + length;
                    while (reader.pos < end) {
                        const tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1: {
                                obj.contentTopic = reader.string();
                                break;
                            }
                            default: {
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                    }
                    return obj;
                });
            }
            return _codec;
        };
        ContentFilter.encode = (obj) => {
            return encodeMessage(obj, ContentFilter.codec());
        };
        ContentFilter.decode = (buf, opts) => {
            return decodeMessage(buf, ContentFilter.codec(), opts);
        };
    })(FilterRequest.ContentFilter || (FilterRequest.ContentFilter = {}));
    let _codec;
    FilterRequest.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.subscribe != null && obj.subscribe !== false)) {
                    w.uint32(8);
                    w.bool(obj.subscribe);
                }
                if ((obj.topic != null && obj.topic !== '')) {
                    w.uint32(18);
                    w.string(obj.topic);
                }
                if (obj.contentFilters != null) {
                    for (const value of obj.contentFilters) {
                        w.uint32(26);
                        FilterRequest.ContentFilter.codec().encode(value, w);
                    }
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    subscribe: false,
                    topic: '',
                    contentFilters: []
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.subscribe = reader.bool();
                            break;
                        }
                        case 2: {
                            obj.topic = reader.string();
                            break;
                        }
                        case 3: {
                            if (opts.limits?.contentFilters != null && obj.contentFilters.length === opts.limits.contentFilters) {
                                throw new MaxLengthError('Decode error - map field "contentFilters" had too many elements');
                            }
                            obj.contentFilters.push(FilterRequest.ContentFilter.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.contentFilters$
                            }));
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    FilterRequest.encode = (obj) => {
        return encodeMessage(obj, FilterRequest.codec());
    };
    FilterRequest.decode = (buf, opts) => {
        return decodeMessage(buf, FilterRequest.codec(), opts);
    };
})(FilterRequest || (FilterRequest = {}));
var MessagePush$1;
(function (MessagePush) {
    let _codec;
    MessagePush.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if (obj.messages != null) {
                    for (const value of obj.messages) {
                        w.uint32(10);
                        WakuMessage$3.codec().encode(value, w);
                    }
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    messages: []
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            if (opts.limits?.messages != null && obj.messages.length === opts.limits.messages) {
                                throw new MaxLengthError('Decode error - map field "messages" had too many elements');
                            }
                            obj.messages.push(WakuMessage$3.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.messages$
                            }));
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    MessagePush.encode = (obj) => {
        return encodeMessage(obj, MessagePush.codec());
    };
    MessagePush.decode = (buf, opts) => {
        return decodeMessage(buf, MessagePush.codec(), opts);
    };
})(MessagePush$1 || (MessagePush$1 = {}));
var FilterRpc;
(function (FilterRpc) {
    let _codec;
    FilterRpc.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.requestId != null && obj.requestId !== '')) {
                    w.uint32(10);
                    w.string(obj.requestId);
                }
                if (obj.request != null) {
                    w.uint32(18);
                    FilterRequest.codec().encode(obj.request, w);
                }
                if (obj.push != null) {
                    w.uint32(26);
                    MessagePush$1.codec().encode(obj.push, w);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    requestId: ''
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.requestId = reader.string();
                            break;
                        }
                        case 2: {
                            obj.request = FilterRequest.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.request
                            });
                            break;
                        }
                        case 3: {
                            obj.push = MessagePush$1.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.push
                            });
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    FilterRpc.encode = (obj) => {
        return encodeMessage(obj, FilterRpc.codec());
    };
    FilterRpc.decode = (buf, opts) => {
        return decodeMessage(buf, FilterRpc.codec(), opts);
    };
})(FilterRpc || (FilterRpc = {}));
var RateLimitProof$3;
(function (RateLimitProof) {
    let _codec;
    RateLimitProof.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.proof != null && obj.proof.byteLength > 0)) {
                    w.uint32(10);
                    w.bytes(obj.proof);
                }
                if ((obj.merkleRoot != null && obj.merkleRoot.byteLength > 0)) {
                    w.uint32(18);
                    w.bytes(obj.merkleRoot);
                }
                if ((obj.epoch != null && obj.epoch.byteLength > 0)) {
                    w.uint32(26);
                    w.bytes(obj.epoch);
                }
                if ((obj.shareX != null && obj.shareX.byteLength > 0)) {
                    w.uint32(34);
                    w.bytes(obj.shareX);
                }
                if ((obj.shareY != null && obj.shareY.byteLength > 0)) {
                    w.uint32(42);
                    w.bytes(obj.shareY);
                }
                if ((obj.nullifier != null && obj.nullifier.byteLength > 0)) {
                    w.uint32(50);
                    w.bytes(obj.nullifier);
                }
                if ((obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0)) {
                    w.uint32(58);
                    w.bytes(obj.rlnIdentifier);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    proof: alloc$1(0),
                    merkleRoot: alloc$1(0),
                    epoch: alloc$1(0),
                    shareX: alloc$1(0),
                    shareY: alloc$1(0),
                    nullifier: alloc$1(0),
                    rlnIdentifier: alloc$1(0)
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.proof = reader.bytes();
                            break;
                        }
                        case 2: {
                            obj.merkleRoot = reader.bytes();
                            break;
                        }
                        case 3: {
                            obj.epoch = reader.bytes();
                            break;
                        }
                        case 4: {
                            obj.shareX = reader.bytes();
                            break;
                        }
                        case 5: {
                            obj.shareY = reader.bytes();
                            break;
                        }
                        case 6: {
                            obj.nullifier = reader.bytes();
                            break;
                        }
                        case 7: {
                            obj.rlnIdentifier = reader.bytes();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    RateLimitProof.encode = (obj) => {
        return encodeMessage(obj, RateLimitProof.codec());
    };
    RateLimitProof.decode = (buf, opts) => {
        return decodeMessage(buf, RateLimitProof.codec(), opts);
    };
})(RateLimitProof$3 || (RateLimitProof$3 = {}));
var WakuMessage$3;
(function (WakuMessage) {
    let _codec;
    WakuMessage.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.payload != null && obj.payload.byteLength > 0)) {
                    w.uint32(10);
                    w.bytes(obj.payload);
                }
                if ((obj.contentTopic != null && obj.contentTopic !== '')) {
                    w.uint32(18);
                    w.string(obj.contentTopic);
                }
                if (obj.version != null) {
                    w.uint32(24);
                    w.uint32(obj.version);
                }
                if (obj.timestamp != null) {
                    w.uint32(80);
                    w.sint64(obj.timestamp);
                }
                if (obj.meta != null) {
                    w.uint32(90);
                    w.bytes(obj.meta);
                }
                if (obj.rateLimitProof != null) {
                    w.uint32(170);
                    RateLimitProof$3.codec().encode(obj.rateLimitProof, w);
                }
                if (obj.ephemeral != null) {
                    w.uint32(248);
                    w.bool(obj.ephemeral);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    payload: alloc$1(0),
                    contentTopic: ''
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.payload = reader.bytes();
                            break;
                        }
                        case 2: {
                            obj.contentTopic = reader.string();
                            break;
                        }
                        case 3: {
                            obj.version = reader.uint32();
                            break;
                        }
                        case 10: {
                            obj.timestamp = reader.sint64();
                            break;
                        }
                        case 11: {
                            obj.meta = reader.bytes();
                            break;
                        }
                        case 21: {
                            obj.rateLimitProof = RateLimitProof$3.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.rateLimitProof
                            });
                            break;
                        }
                        case 31: {
                            obj.ephemeral = reader.bool();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    WakuMessage.encode = (obj) => {
        return encodeMessage(obj, WakuMessage.codec());
    };
    WakuMessage.decode = (buf, opts) => {
        return decodeMessage(buf, WakuMessage.codec(), opts);
    };
})(WakuMessage$3 || (WakuMessage$3 = {}));

/* eslint-disable import/export */
/* eslint-disable complexity */
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */
/* eslint-disable @typescript-eslint/no-empty-interface */
var TopicOnlyMessage;
(function (TopicOnlyMessage) {
    let _codec;
    TopicOnlyMessage.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.contentTopic != null && obj.contentTopic !== '')) {
                    w.uint32(18);
                    w.string(obj.contentTopic);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    contentTopic: ''
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 2: {
                            obj.contentTopic = reader.string();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    TopicOnlyMessage.encode = (obj) => {
        return encodeMessage(obj, TopicOnlyMessage.codec());
    };
    TopicOnlyMessage.decode = (buf, opts) => {
        return decodeMessage(buf, TopicOnlyMessage.codec(), opts);
    };
})(TopicOnlyMessage || (TopicOnlyMessage = {}));

/* eslint-disable import/export */
/* eslint-disable complexity */
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */
/* eslint-disable @typescript-eslint/no-empty-interface */
var FilterSubscribeRequest;
(function (FilterSubscribeRequest) {
    let FilterSubscribeType;
    (function (FilterSubscribeType) {
        FilterSubscribeType["SUBSCRIBER_PING"] = "SUBSCRIBER_PING";
        FilterSubscribeType["SUBSCRIBE"] = "SUBSCRIBE";
        FilterSubscribeType["UNSUBSCRIBE"] = "UNSUBSCRIBE";
        FilterSubscribeType["UNSUBSCRIBE_ALL"] = "UNSUBSCRIBE_ALL";
    })(FilterSubscribeType = FilterSubscribeRequest.FilterSubscribeType || (FilterSubscribeRequest.FilterSubscribeType = {}));
    let __FilterSubscribeTypeValues;
    (function (__FilterSubscribeTypeValues) {
        __FilterSubscribeTypeValues[__FilterSubscribeTypeValues["SUBSCRIBER_PING"] = 0] = "SUBSCRIBER_PING";
        __FilterSubscribeTypeValues[__FilterSubscribeTypeValues["SUBSCRIBE"] = 1] = "SUBSCRIBE";
        __FilterSubscribeTypeValues[__FilterSubscribeTypeValues["UNSUBSCRIBE"] = 2] = "UNSUBSCRIBE";
        __FilterSubscribeTypeValues[__FilterSubscribeTypeValues["UNSUBSCRIBE_ALL"] = 3] = "UNSUBSCRIBE_ALL";
    })(__FilterSubscribeTypeValues || (__FilterSubscribeTypeValues = {}));
    (function (FilterSubscribeType) {
        FilterSubscribeType.codec = () => {
            return enumeration(__FilterSubscribeTypeValues);
        };
    })(FilterSubscribeType = FilterSubscribeRequest.FilterSubscribeType || (FilterSubscribeRequest.FilterSubscribeType = {}));
    let _codec;
    FilterSubscribeRequest.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.requestId != null && obj.requestId !== '')) {
                    w.uint32(10);
                    w.string(obj.requestId);
                }
                if (obj.filterSubscribeType != null && __FilterSubscribeTypeValues[obj.filterSubscribeType] !== 0) {
                    w.uint32(16);
                    FilterSubscribeRequest.FilterSubscribeType.codec().encode(obj.filterSubscribeType, w);
                }
                if (obj.pubsubTopic != null) {
                    w.uint32(82);
                    w.string(obj.pubsubTopic);
                }
                if (obj.contentTopics != null) {
                    for (const value of obj.contentTopics) {
                        w.uint32(90);
                        w.string(value);
                    }
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    requestId: '',
                    filterSubscribeType: FilterSubscribeType.SUBSCRIBER_PING,
                    contentTopics: []
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.requestId = reader.string();
                            break;
                        }
                        case 2: {
                            obj.filterSubscribeType = FilterSubscribeRequest.FilterSubscribeType.codec().decode(reader);
                            break;
                        }
                        case 10: {
                            obj.pubsubTopic = reader.string();
                            break;
                        }
                        case 11: {
                            if (opts.limits?.contentTopics != null && obj.contentTopics.length === opts.limits.contentTopics) {
                                throw new MaxLengthError('Decode error - map field "contentTopics" had too many elements');
                            }
                            obj.contentTopics.push(reader.string());
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    FilterSubscribeRequest.encode = (obj) => {
        return encodeMessage(obj, FilterSubscribeRequest.codec());
    };
    FilterSubscribeRequest.decode = (buf, opts) => {
        return decodeMessage(buf, FilterSubscribeRequest.codec(), opts);
    };
})(FilterSubscribeRequest || (FilterSubscribeRequest = {}));
var FilterSubscribeResponse$1;
(function (FilterSubscribeResponse) {
    let _codec;
    FilterSubscribeResponse.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.requestId != null && obj.requestId !== '')) {
                    w.uint32(10);
                    w.string(obj.requestId);
                }
                if ((obj.statusCode != null && obj.statusCode !== 0)) {
                    w.uint32(80);
                    w.uint32(obj.statusCode);
                }
                if (obj.statusDesc != null) {
                    w.uint32(90);
                    w.string(obj.statusDesc);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    requestId: '',
                    statusCode: 0
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.requestId = reader.string();
                            break;
                        }
                        case 10: {
                            obj.statusCode = reader.uint32();
                            break;
                        }
                        case 11: {
                            obj.statusDesc = reader.string();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    FilterSubscribeResponse.encode = (obj) => {
        return encodeMessage(obj, FilterSubscribeResponse.codec());
    };
    FilterSubscribeResponse.decode = (buf, opts) => {
        return decodeMessage(buf, FilterSubscribeResponse.codec(), opts);
    };
})(FilterSubscribeResponse$1 || (FilterSubscribeResponse$1 = {}));
var MessagePush;
(function (MessagePush) {
    let _codec;
    MessagePush.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if (obj.wakuMessage != null) {
                    w.uint32(10);
                    WakuMessage$2.codec().encode(obj.wakuMessage, w);
                }
                if (obj.pubsubTopic != null) {
                    w.uint32(18);
                    w.string(obj.pubsubTopic);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {};
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.wakuMessage = WakuMessage$2.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.wakuMessage
                            });
                            break;
                        }
                        case 2: {
                            obj.pubsubTopic = reader.string();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    MessagePush.encode = (obj) => {
        return encodeMessage(obj, MessagePush.codec());
    };
    MessagePush.decode = (buf, opts) => {
        return decodeMessage(buf, MessagePush.codec(), opts);
    };
})(MessagePush || (MessagePush = {}));
var RateLimitProof$2;
(function (RateLimitProof) {
    let _codec;
    RateLimitProof.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.proof != null && obj.proof.byteLength > 0)) {
                    w.uint32(10);
                    w.bytes(obj.proof);
                }
                if ((obj.merkleRoot != null && obj.merkleRoot.byteLength > 0)) {
                    w.uint32(18);
                    w.bytes(obj.merkleRoot);
                }
                if ((obj.epoch != null && obj.epoch.byteLength > 0)) {
                    w.uint32(26);
                    w.bytes(obj.epoch);
                }
                if ((obj.shareX != null && obj.shareX.byteLength > 0)) {
                    w.uint32(34);
                    w.bytes(obj.shareX);
                }
                if ((obj.shareY != null && obj.shareY.byteLength > 0)) {
                    w.uint32(42);
                    w.bytes(obj.shareY);
                }
                if ((obj.nullifier != null && obj.nullifier.byteLength > 0)) {
                    w.uint32(50);
                    w.bytes(obj.nullifier);
                }
                if ((obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0)) {
                    w.uint32(58);
                    w.bytes(obj.rlnIdentifier);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    proof: alloc$1(0),
                    merkleRoot: alloc$1(0),
                    epoch: alloc$1(0),
                    shareX: alloc$1(0),
                    shareY: alloc$1(0),
                    nullifier: alloc$1(0),
                    rlnIdentifier: alloc$1(0)
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.proof = reader.bytes();
                            break;
                        }
                        case 2: {
                            obj.merkleRoot = reader.bytes();
                            break;
                        }
                        case 3: {
                            obj.epoch = reader.bytes();
                            break;
                        }
                        case 4: {
                            obj.shareX = reader.bytes();
                            break;
                        }
                        case 5: {
                            obj.shareY = reader.bytes();
                            break;
                        }
                        case 6: {
                            obj.nullifier = reader.bytes();
                            break;
                        }
                        case 7: {
                            obj.rlnIdentifier = reader.bytes();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    RateLimitProof.encode = (obj) => {
        return encodeMessage(obj, RateLimitProof.codec());
    };
    RateLimitProof.decode = (buf, opts) => {
        return decodeMessage(buf, RateLimitProof.codec(), opts);
    };
})(RateLimitProof$2 || (RateLimitProof$2 = {}));
var WakuMessage$2;
(function (WakuMessage) {
    let _codec;
    WakuMessage.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.payload != null && obj.payload.byteLength > 0)) {
                    w.uint32(10);
                    w.bytes(obj.payload);
                }
                if ((obj.contentTopic != null && obj.contentTopic !== '')) {
                    w.uint32(18);
                    w.string(obj.contentTopic);
                }
                if (obj.version != null) {
                    w.uint32(24);
                    w.uint32(obj.version);
                }
                if (obj.timestamp != null) {
                    w.uint32(80);
                    w.sint64(obj.timestamp);
                }
                if (obj.meta != null) {
                    w.uint32(90);
                    w.bytes(obj.meta);
                }
                if (obj.rateLimitProof != null) {
                    w.uint32(170);
                    RateLimitProof$2.codec().encode(obj.rateLimitProof, w);
                }
                if (obj.ephemeral != null) {
                    w.uint32(248);
                    w.bool(obj.ephemeral);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    payload: alloc$1(0),
                    contentTopic: ''
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.payload = reader.bytes();
                            break;
                        }
                        case 2: {
                            obj.contentTopic = reader.string();
                            break;
                        }
                        case 3: {
                            obj.version = reader.uint32();
                            break;
                        }
                        case 10: {
                            obj.timestamp = reader.sint64();
                            break;
                        }
                        case 11: {
                            obj.meta = reader.bytes();
                            break;
                        }
                        case 21: {
                            obj.rateLimitProof = RateLimitProof$2.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.rateLimitProof
                            });
                            break;
                        }
                        case 31: {
                            obj.ephemeral = reader.bool();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    WakuMessage.encode = (obj) => {
        return encodeMessage(obj, WakuMessage.codec());
    };
    WakuMessage.decode = (buf, opts) => {
        return decodeMessage(buf, WakuMessage.codec(), opts);
    };
})(WakuMessage$2 || (WakuMessage$2 = {}));

/* eslint-disable import/export */
/* eslint-disable complexity */
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */
/* eslint-disable @typescript-eslint/no-empty-interface */
var PushRequest;
(function (PushRequest) {
    let _codec;
    PushRequest.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.pubsubTopic != null && obj.pubsubTopic !== '')) {
                    w.uint32(10);
                    w.string(obj.pubsubTopic);
                }
                if (obj.message != null) {
                    w.uint32(18);
                    WakuMessage$1.codec().encode(obj.message, w);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    pubsubTopic: ''
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.pubsubTopic = reader.string();
                            break;
                        }
                        case 2: {
                            obj.message = WakuMessage$1.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.message
                            });
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    PushRequest.encode = (obj) => {
        return encodeMessage(obj, PushRequest.codec());
    };
    PushRequest.decode = (buf, opts) => {
        return decodeMessage(buf, PushRequest.codec(), opts);
    };
})(PushRequest || (PushRequest = {}));
var PushResponse;
(function (PushResponse) {
    let _codec;
    PushResponse.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.isSuccess != null && obj.isSuccess !== false)) {
                    w.uint32(8);
                    w.bool(obj.isSuccess);
                }
                if (obj.info != null) {
                    w.uint32(18);
                    w.string(obj.info);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    isSuccess: false
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.isSuccess = reader.bool();
                            break;
                        }
                        case 2: {
                            obj.info = reader.string();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    PushResponse.encode = (obj) => {
        return encodeMessage(obj, PushResponse.codec());
    };
    PushResponse.decode = (buf, opts) => {
        return decodeMessage(buf, PushResponse.codec(), opts);
    };
})(PushResponse || (PushResponse = {}));
var PushRpc$1;
(function (PushRpc) {
    let _codec;
    PushRpc.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.requestId != null && obj.requestId !== '')) {
                    w.uint32(10);
                    w.string(obj.requestId);
                }
                if (obj.request != null) {
                    w.uint32(18);
                    PushRequest.codec().encode(obj.request, w);
                }
                if (obj.response != null) {
                    w.uint32(26);
                    PushResponse.codec().encode(obj.response, w);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    requestId: ''
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.requestId = reader.string();
                            break;
                        }
                        case 2: {
                            obj.request = PushRequest.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.request
                            });
                            break;
                        }
                        case 3: {
                            obj.response = PushResponse.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.response
                            });
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    PushRpc.encode = (obj) => {
        return encodeMessage(obj, PushRpc.codec());
    };
    PushRpc.decode = (buf, opts) => {
        return decodeMessage(buf, PushRpc.codec(), opts);
    };
})(PushRpc$1 || (PushRpc$1 = {}));
var RateLimitProof$1;
(function (RateLimitProof) {
    let _codec;
    RateLimitProof.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.proof != null && obj.proof.byteLength > 0)) {
                    w.uint32(10);
                    w.bytes(obj.proof);
                }
                if ((obj.merkleRoot != null && obj.merkleRoot.byteLength > 0)) {
                    w.uint32(18);
                    w.bytes(obj.merkleRoot);
                }
                if ((obj.epoch != null && obj.epoch.byteLength > 0)) {
                    w.uint32(26);
                    w.bytes(obj.epoch);
                }
                if ((obj.shareX != null && obj.shareX.byteLength > 0)) {
                    w.uint32(34);
                    w.bytes(obj.shareX);
                }
                if ((obj.shareY != null && obj.shareY.byteLength > 0)) {
                    w.uint32(42);
                    w.bytes(obj.shareY);
                }
                if ((obj.nullifier != null && obj.nullifier.byteLength > 0)) {
                    w.uint32(50);
                    w.bytes(obj.nullifier);
                }
                if ((obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0)) {
                    w.uint32(58);
                    w.bytes(obj.rlnIdentifier);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    proof: alloc$1(0),
                    merkleRoot: alloc$1(0),
                    epoch: alloc$1(0),
                    shareX: alloc$1(0),
                    shareY: alloc$1(0),
                    nullifier: alloc$1(0),
                    rlnIdentifier: alloc$1(0)
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.proof = reader.bytes();
                            break;
                        }
                        case 2: {
                            obj.merkleRoot = reader.bytes();
                            break;
                        }
                        case 3: {
                            obj.epoch = reader.bytes();
                            break;
                        }
                        case 4: {
                            obj.shareX = reader.bytes();
                            break;
                        }
                        case 5: {
                            obj.shareY = reader.bytes();
                            break;
                        }
                        case 6: {
                            obj.nullifier = reader.bytes();
                            break;
                        }
                        case 7: {
                            obj.rlnIdentifier = reader.bytes();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    RateLimitProof.encode = (obj) => {
        return encodeMessage(obj, RateLimitProof.codec());
    };
    RateLimitProof.decode = (buf, opts) => {
        return decodeMessage(buf, RateLimitProof.codec(), opts);
    };
})(RateLimitProof$1 || (RateLimitProof$1 = {}));
var WakuMessage$1;
(function (WakuMessage) {
    let _codec;
    WakuMessage.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.payload != null && obj.payload.byteLength > 0)) {
                    w.uint32(10);
                    w.bytes(obj.payload);
                }
                if ((obj.contentTopic != null && obj.contentTopic !== '')) {
                    w.uint32(18);
                    w.string(obj.contentTopic);
                }
                if (obj.version != null) {
                    w.uint32(24);
                    w.uint32(obj.version);
                }
                if (obj.timestamp != null) {
                    w.uint32(80);
                    w.sint64(obj.timestamp);
                }
                if (obj.meta != null) {
                    w.uint32(90);
                    w.bytes(obj.meta);
                }
                if (obj.rateLimitProof != null) {
                    w.uint32(170);
                    RateLimitProof$1.codec().encode(obj.rateLimitProof, w);
                }
                if (obj.ephemeral != null) {
                    w.uint32(248);
                    w.bool(obj.ephemeral);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    payload: alloc$1(0),
                    contentTopic: ''
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.payload = reader.bytes();
                            break;
                        }
                        case 2: {
                            obj.contentTopic = reader.string();
                            break;
                        }
                        case 3: {
                            obj.version = reader.uint32();
                            break;
                        }
                        case 10: {
                            obj.timestamp = reader.sint64();
                            break;
                        }
                        case 11: {
                            obj.meta = reader.bytes();
                            break;
                        }
                        case 21: {
                            obj.rateLimitProof = RateLimitProof$1.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.rateLimitProof
                            });
                            break;
                        }
                        case 31: {
                            obj.ephemeral = reader.bool();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    WakuMessage.encode = (obj) => {
        return encodeMessage(obj, WakuMessage.codec());
    };
    WakuMessage.decode = (buf, opts) => {
        return decodeMessage(buf, WakuMessage.codec(), opts);
    };
})(WakuMessage$1 || (WakuMessage$1 = {}));

/* eslint-disable import/export */
/* eslint-disable complexity */
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */
/* eslint-disable @typescript-eslint/no-empty-interface */
var WakuMessageKeyValue;
(function (WakuMessageKeyValue) {
    let _codec;
    WakuMessageKeyValue.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if (obj.messageHash != null) {
                    w.uint32(10);
                    w.bytes(obj.messageHash);
                }
                if (obj.message != null) {
                    w.uint32(18);
                    WakuMessage.codec().encode(obj.message, w);
                }
                if (obj.pubsubTopic != null) {
                    w.uint32(26);
                    w.string(obj.pubsubTopic);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {};
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.messageHash = reader.bytes();
                            break;
                        }
                        case 2: {
                            obj.message = WakuMessage.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.message
                            });
                            break;
                        }
                        case 3: {
                            obj.pubsubTopic = reader.string();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    WakuMessageKeyValue.encode = (obj) => {
        return encodeMessage(obj, WakuMessageKeyValue.codec());
    };
    WakuMessageKeyValue.decode = (buf, opts) => {
        return decodeMessage(buf, WakuMessageKeyValue.codec(), opts);
    };
})(WakuMessageKeyValue || (WakuMessageKeyValue = {}));
var StoreQueryRequest$1;
(function (StoreQueryRequest) {
    let _codec;
    StoreQueryRequest.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.requestId != null && obj.requestId !== '')) {
                    w.uint32(10);
                    w.string(obj.requestId);
                }
                if ((obj.includeData != null && obj.includeData !== false)) {
                    w.uint32(16);
                    w.bool(obj.includeData);
                }
                if (obj.pubsubTopic != null) {
                    w.uint32(82);
                    w.string(obj.pubsubTopic);
                }
                if (obj.contentTopics != null) {
                    for (const value of obj.contentTopics) {
                        w.uint32(90);
                        w.string(value);
                    }
                }
                if (obj.timeStart != null) {
                    w.uint32(96);
                    w.sint64(obj.timeStart);
                }
                if (obj.timeEnd != null) {
                    w.uint32(104);
                    w.sint64(obj.timeEnd);
                }
                if (obj.messageHashes != null) {
                    for (const value of obj.messageHashes) {
                        w.uint32(162);
                        w.bytes(value);
                    }
                }
                if (obj.paginationCursor != null) {
                    w.uint32(410);
                    w.bytes(obj.paginationCursor);
                }
                if ((obj.paginationForward != null && obj.paginationForward !== false)) {
                    w.uint32(416);
                    w.bool(obj.paginationForward);
                }
                if (obj.paginationLimit != null) {
                    w.uint32(424);
                    w.uint64(obj.paginationLimit);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    requestId: '',
                    includeData: false,
                    contentTopics: [],
                    messageHashes: [],
                    paginationForward: false
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.requestId = reader.string();
                            break;
                        }
                        case 2: {
                            obj.includeData = reader.bool();
                            break;
                        }
                        case 10: {
                            obj.pubsubTopic = reader.string();
                            break;
                        }
                        case 11: {
                            if (opts.limits?.contentTopics != null && obj.contentTopics.length === opts.limits.contentTopics) {
                                throw new MaxLengthError('Decode error - map field "contentTopics" had too many elements');
                            }
                            obj.contentTopics.push(reader.string());
                            break;
                        }
                        case 12: {
                            obj.timeStart = reader.sint64();
                            break;
                        }
                        case 13: {
                            obj.timeEnd = reader.sint64();
                            break;
                        }
                        case 20: {
                            if (opts.limits?.messageHashes != null && obj.messageHashes.length === opts.limits.messageHashes) {
                                throw new MaxLengthError('Decode error - map field "messageHashes" had too many elements');
                            }
                            obj.messageHashes.push(reader.bytes());
                            break;
                        }
                        case 51: {
                            obj.paginationCursor = reader.bytes();
                            break;
                        }
                        case 52: {
                            obj.paginationForward = reader.bool();
                            break;
                        }
                        case 53: {
                            obj.paginationLimit = reader.uint64();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    StoreQueryRequest.encode = (obj) => {
        return encodeMessage(obj, StoreQueryRequest.codec());
    };
    StoreQueryRequest.decode = (buf, opts) => {
        return decodeMessage(buf, StoreQueryRequest.codec(), opts);
    };
})(StoreQueryRequest$1 || (StoreQueryRequest$1 = {}));
var StoreQueryResponse$1;
(function (StoreQueryResponse) {
    let _codec;
    StoreQueryResponse.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.requestId != null && obj.requestId !== '')) {
                    w.uint32(10);
                    w.string(obj.requestId);
                }
                if (obj.statusCode != null) {
                    w.uint32(80);
                    w.uint32(obj.statusCode);
                }
                if (obj.statusDesc != null) {
                    w.uint32(90);
                    w.string(obj.statusDesc);
                }
                if (obj.messages != null) {
                    for (const value of obj.messages) {
                        w.uint32(162);
                        WakuMessageKeyValue.codec().encode(value, w);
                    }
                }
                if (obj.paginationCursor != null) {
                    w.uint32(410);
                    w.bytes(obj.paginationCursor);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    requestId: '',
                    messages: []
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.requestId = reader.string();
                            break;
                        }
                        case 10: {
                            obj.statusCode = reader.uint32();
                            break;
                        }
                        case 11: {
                            obj.statusDesc = reader.string();
                            break;
                        }
                        case 20: {
                            if (opts.limits?.messages != null && obj.messages.length === opts.limits.messages) {
                                throw new MaxLengthError('Decode error - map field "messages" had too many elements');
                            }
                            obj.messages.push(WakuMessageKeyValue.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.messages$
                            }));
                            break;
                        }
                        case 51: {
                            obj.paginationCursor = reader.bytes();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    StoreQueryResponse.encode = (obj) => {
        return encodeMessage(obj, StoreQueryResponse.codec());
    };
    StoreQueryResponse.decode = (buf, opts) => {
        return decodeMessage(buf, StoreQueryResponse.codec(), opts);
    };
})(StoreQueryResponse$1 || (StoreQueryResponse$1 = {}));
var RateLimitProof;
(function (RateLimitProof) {
    let _codec;
    RateLimitProof.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.proof != null && obj.proof.byteLength > 0)) {
                    w.uint32(10);
                    w.bytes(obj.proof);
                }
                if ((obj.merkleRoot != null && obj.merkleRoot.byteLength > 0)) {
                    w.uint32(18);
                    w.bytes(obj.merkleRoot);
                }
                if ((obj.epoch != null && obj.epoch.byteLength > 0)) {
                    w.uint32(26);
                    w.bytes(obj.epoch);
                }
                if ((obj.shareX != null && obj.shareX.byteLength > 0)) {
                    w.uint32(34);
                    w.bytes(obj.shareX);
                }
                if ((obj.shareY != null && obj.shareY.byteLength > 0)) {
                    w.uint32(42);
                    w.bytes(obj.shareY);
                }
                if ((obj.nullifier != null && obj.nullifier.byteLength > 0)) {
                    w.uint32(50);
                    w.bytes(obj.nullifier);
                }
                if ((obj.rlnIdentifier != null && obj.rlnIdentifier.byteLength > 0)) {
                    w.uint32(58);
                    w.bytes(obj.rlnIdentifier);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    proof: alloc$1(0),
                    merkleRoot: alloc$1(0),
                    epoch: alloc$1(0),
                    shareX: alloc$1(0),
                    shareY: alloc$1(0),
                    nullifier: alloc$1(0),
                    rlnIdentifier: alloc$1(0)
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.proof = reader.bytes();
                            break;
                        }
                        case 2: {
                            obj.merkleRoot = reader.bytes();
                            break;
                        }
                        case 3: {
                            obj.epoch = reader.bytes();
                            break;
                        }
                        case 4: {
                            obj.shareX = reader.bytes();
                            break;
                        }
                        case 5: {
                            obj.shareY = reader.bytes();
                            break;
                        }
                        case 6: {
                            obj.nullifier = reader.bytes();
                            break;
                        }
                        case 7: {
                            obj.rlnIdentifier = reader.bytes();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    RateLimitProof.encode = (obj) => {
        return encodeMessage(obj, RateLimitProof.codec());
    };
    RateLimitProof.decode = (buf, opts) => {
        return decodeMessage(buf, RateLimitProof.codec(), opts);
    };
})(RateLimitProof || (RateLimitProof = {}));
var WakuMessage;
(function (WakuMessage) {
    let _codec;
    WakuMessage.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if ((obj.payload != null && obj.payload.byteLength > 0)) {
                    w.uint32(10);
                    w.bytes(obj.payload);
                }
                if ((obj.contentTopic != null && obj.contentTopic !== '')) {
                    w.uint32(18);
                    w.string(obj.contentTopic);
                }
                if (obj.version != null) {
                    w.uint32(24);
                    w.uint32(obj.version);
                }
                if (obj.timestamp != null) {
                    w.uint32(80);
                    w.sint64(obj.timestamp);
                }
                if (obj.meta != null) {
                    w.uint32(90);
                    w.bytes(obj.meta);
                }
                if (obj.rateLimitProof != null) {
                    w.uint32(170);
                    RateLimitProof.codec().encode(obj.rateLimitProof, w);
                }
                if (obj.ephemeral != null) {
                    w.uint32(248);
                    w.bool(obj.ephemeral);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    payload: alloc$1(0),
                    contentTopic: ''
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.payload = reader.bytes();
                            break;
                        }
                        case 2: {
                            obj.contentTopic = reader.string();
                            break;
                        }
                        case 3: {
                            obj.version = reader.uint32();
                            break;
                        }
                        case 10: {
                            obj.timestamp = reader.sint64();
                            break;
                        }
                        case 11: {
                            obj.meta = reader.bytes();
                            break;
                        }
                        case 21: {
                            obj.rateLimitProof = RateLimitProof.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.rateLimitProof
                            });
                            break;
                        }
                        case 31: {
                            obj.ephemeral = reader.bool();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    WakuMessage.encode = (obj) => {
        return encodeMessage(obj, WakuMessage.codec());
    };
    WakuMessage.decode = (buf, opts) => {
        return decodeMessage(buf, WakuMessage.codec(), opts);
    };
})(WakuMessage || (WakuMessage = {}));

/* eslint-disable import/export */
/* eslint-disable complexity */
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */
/* eslint-disable @typescript-eslint/no-empty-interface */
var PeerInfo;
(function (PeerInfo) {
    let _codec;
    PeerInfo.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if (obj.enr != null) {
                    w.uint32(10);
                    w.bytes(obj.enr);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {};
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.enr = reader.bytes();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    PeerInfo.encode = (obj) => {
        return encodeMessage(obj, PeerInfo.codec());
    };
    PeerInfo.decode = (buf, opts) => {
        return decodeMessage(buf, PeerInfo.codec(), opts);
    };
})(PeerInfo || (PeerInfo = {}));
var PeerExchangeQuery;
(function (PeerExchangeQuery) {
    let _codec;
    PeerExchangeQuery.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if (obj.numPeers != null) {
                    w.uint32(8);
                    w.uint64(obj.numPeers);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {};
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.numPeers = reader.uint64();
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    PeerExchangeQuery.encode = (obj) => {
        return encodeMessage(obj, PeerExchangeQuery.codec());
    };
    PeerExchangeQuery.decode = (buf, opts) => {
        return decodeMessage(buf, PeerExchangeQuery.codec(), opts);
    };
})(PeerExchangeQuery || (PeerExchangeQuery = {}));
var PeerExchangeResponse;
(function (PeerExchangeResponse) {
    let _codec;
    PeerExchangeResponse.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if (obj.peerInfos != null) {
                    for (const value of obj.peerInfos) {
                        w.uint32(10);
                        PeerInfo.codec().encode(value, w);
                    }
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    peerInfos: []
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            if (opts.limits?.peerInfos != null && obj.peerInfos.length === opts.limits.peerInfos) {
                                throw new MaxLengthError('Decode error - map field "peerInfos" had too many elements');
                            }
                            obj.peerInfos.push(PeerInfo.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.peerInfos$
                            }));
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    PeerExchangeResponse.encode = (obj) => {
        return encodeMessage(obj, PeerExchangeResponse.codec());
    };
    PeerExchangeResponse.decode = (buf, opts) => {
        return decodeMessage(buf, PeerExchangeResponse.codec(), opts);
    };
})(PeerExchangeResponse || (PeerExchangeResponse = {}));
var PeerExchangeRPC;
(function (PeerExchangeRPC) {
    let _codec;
    PeerExchangeRPC.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if (obj.query != null) {
                    w.uint32(10);
                    PeerExchangeQuery.codec().encode(obj.query, w);
                }
                if (obj.response != null) {
                    w.uint32(18);
                    PeerExchangeResponse.codec().encode(obj.response, w);
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {};
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.query = PeerExchangeQuery.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.query
                            });
                            break;
                        }
                        case 2: {
                            obj.response = PeerExchangeResponse.codec().decode(reader, reader.uint32(), {
                                limits: opts.limits?.response
                            });
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    PeerExchangeRPC.encode = (obj) => {
        return encodeMessage(obj, PeerExchangeRPC.codec());
    };
    PeerExchangeRPC.decode = (buf, opts) => {
        return decodeMessage(buf, PeerExchangeRPC.codec(), opts);
    };
})(PeerExchangeRPC || (PeerExchangeRPC = {}));

/* eslint-disable import/export */
/* eslint-disable complexity */
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */
/* eslint-disable @typescript-eslint/no-empty-interface */
var WakuMetadataRequest;
(function (WakuMetadataRequest) {
    let _codec;
    WakuMetadataRequest.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if (obj.clusterId != null) {
                    w.uint32(8);
                    w.uint32(obj.clusterId);
                }
                if (obj.shards != null) {
                    for (const value of obj.shards) {
                        w.uint32(16);
                        w.uint32(value);
                    }
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    shards: []
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.clusterId = reader.uint32();
                            break;
                        }
                        case 2: {
                            if (opts.limits?.shards != null && obj.shards.length === opts.limits.shards) {
                                throw new MaxLengthError('Decode error - map field "shards" had too many elements');
                            }
                            obj.shards.push(reader.uint32());
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    WakuMetadataRequest.encode = (obj) => {
        return encodeMessage(obj, WakuMetadataRequest.codec());
    };
    WakuMetadataRequest.decode = (buf, opts) => {
        return decodeMessage(buf, WakuMetadataRequest.codec(), opts);
    };
})(WakuMetadataRequest || (WakuMetadataRequest = {}));
var WakuMetadataResponse;
(function (WakuMetadataResponse) {
    let _codec;
    WakuMetadataResponse.codec = () => {
        if (_codec == null) {
            _codec = message$1((obj, w, opts = {}) => {
                if (opts.lengthDelimited !== false) {
                    w.fork();
                }
                if (obj.clusterId != null) {
                    w.uint32(8);
                    w.uint32(obj.clusterId);
                }
                if (obj.shards != null) {
                    for (const value of obj.shards) {
                        w.uint32(16);
                        w.uint32(value);
                    }
                }
                if (opts.lengthDelimited !== false) {
                    w.ldelim();
                }
            }, (reader, length, opts = {}) => {
                const obj = {
                    shards: []
                };
                const end = length == null ? reader.len : reader.pos + length;
                while (reader.pos < end) {
                    const tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1: {
                            obj.clusterId = reader.uint32();
                            break;
                        }
                        case 2: {
                            if (opts.limits?.shards != null && obj.shards.length === opts.limits.shards) {
                                throw new MaxLengthError('Decode error - map field "shards" had too many elements');
                            }
                            obj.shards.push(reader.uint32());
                            break;
                        }
                        default: {
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                }
                return obj;
            });
        }
        return _codec;
    };
    WakuMetadataResponse.encode = (obj) => {
        return encodeMessage(obj, WakuMetadataResponse.codec());
    };
    WakuMetadataResponse.decode = (buf, opts) => {
        return decodeMessage(buf, WakuMetadataResponse.codec(), opts);
    };
})(WakuMetadataResponse || (WakuMetadataResponse = {}));

// copied from utils
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
function bytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    bytes(data);
    return data;
}
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}

/**
 * Polyfill for Safari 14
 */
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/**
 * Choice: a ? b : c
 */
const Chi = (a, b, c) => (a & b) ^ (~a & c);
/**
 * Majority function, true if any two inputs is true
 */
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */
class HashMD extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
    }
    update(data) {
        exists(this);
        const { view, buffer, blockLen } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = createView(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        exists(this);
        output(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = createView(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}

// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state:
// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
// prettier-ignore
const SHA256_IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends HashMD {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);
            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

/**
 * The default cluster ID for The Waku Network
 */
const DEFAULT_CLUSTER_ID = 1;

const singleShardInfoToPubsubTopic = (shardInfo) => {
    if (shardInfo.shard === undefined)
        throw new Error("Invalid shard");
    return `/waku/2/rs/${shardInfo.clusterId ?? DEFAULT_CLUSTER_ID}/${shardInfo.shard}`;
};
const shardInfoToPubsubTopics = (shardInfo) => {
    if ("contentTopics" in shardInfo && shardInfo.contentTopics) {
        // Autosharding: explicitly defined content topics
        return Array.from(new Set(shardInfo.contentTopics.map((contentTopic) => contentTopicToPubsubTopic(contentTopic, shardInfo.clusterId))));
    }
    else if ("shards" in shardInfo) {
        // Static sharding
        if (shardInfo.shards === undefined)
            throw new Error("Invalid shard");
        return Array.from(new Set(shardInfo.shards.map((index) => `/waku/2/rs/${shardInfo.clusterId ?? DEFAULT_CLUSTER_ID}/${index}`)));
    }
    else if ("application" in shardInfo && "version" in shardInfo) {
        // Autosharding: single shard from application and version
        return [
            contentTopicToPubsubTopic(`/${shardInfo.application}/${shardInfo.version}/default/default`, shardInfo.clusterId)
        ];
    }
    else {
        throw new Error("Missing required configuration in shard parameters");
    }
};
const pubsubTopicToSingleShardInfo = (pubsubTopics) => {
    const parts = pubsubTopics.split("/");
    if (parts.length != 6 ||
        parts[1] !== "waku" ||
        parts[2] !== "2" ||
        parts[3] !== "rs")
        throw new Error("Invalid pubsub topic");
    const clusterId = parseInt(parts[4]);
    const shard = parseInt(parts[5]);
    if (isNaN(clusterId) || isNaN(shard))
        throw new Error("Invalid clusterId or shard");
    return {
        clusterId,
        shard
    };
};
const pubsubTopicsToShardInfo = (pubsubTopics) => {
    const shardInfoSet = new Set();
    const clusterIds = new Set();
    for (const topic of pubsubTopics) {
        const { clusterId, shard } = pubsubTopicToSingleShardInfo(topic);
        shardInfoSet.add(`${clusterId}:${shard}`);
        clusterIds.add(clusterId);
    }
    if (shardInfoSet.size === 0) {
        throw new Error("No valid pubsub topics provided");
    }
    if (clusterIds.size > 1) {
        throw new Error("Pubsub topics from multiple cluster IDs are not supported");
    }
    const clusterId = clusterIds.values().next().value;
    const shards = Array.from(shardInfoSet).map((info) => parseInt(info.split(":")[1]));
    return {
        clusterId,
        shards
    };
};
/**
 * Given a string, will throw an error if it is not formatted as a valid content topic for autosharding based on https://rfc.vac.dev/spec/51/
 * @param contentTopic String to validate
 * @returns Object with each content topic field as an attribute
 */
function ensureValidContentTopic(contentTopic) {
    const parts = contentTopic.split("/");
    if (parts.length < 5 || parts.length > 6) {
        throw Error("Content topic format is invalid");
    }
    // Validate generation field if present
    let generation = 0;
    if (parts.length == 6) {
        generation = parseInt(parts[1]);
        if (isNaN(generation)) {
            throw new Error("Invalid generation field in content topic");
        }
        if (generation > 0) {
            throw new Error("Generation greater than 0 is not supported");
        }
    }
    // Validate remaining fields
    const fields = parts.splice(-4);
    // Validate application field
    if (fields[0].length == 0) {
        throw new Error("Application field cannot be empty");
    }
    // Validate version field
    if (fields[1].length == 0) {
        throw new Error("Version field cannot be empty");
    }
    // Validate topic name field
    if (fields[2].length == 0) {
        throw new Error("Topic name field cannot be empty");
    }
    // Validate encoding field
    if (fields[3].length == 0) {
        throw new Error("Encoding field cannot be empty");
    }
    return {
        generation,
        application: fields[0],
        version: fields[1],
        topicName: fields[2],
        encoding: fields[3]
    };
}
/**
 * Given a string, determines which autoshard index to use for its pubsub topic.
 * Based on the algorithm described in the RFC: https://rfc.vac.dev/spec/51//#algorithm
 */
function contentTopicToShardIndex(contentTopic, networkShards = 8) {
    const { application, version } = ensureValidContentTopic(contentTopic);
    const digest = sha256(concat([utf8ToBytes$1(application), utf8ToBytes$1(version)]));
    const dataview = new DataView(digest.buffer.slice(-8));
    return Number(dataview.getBigUint64(0, false) % BigInt(networkShards));
}
function contentTopicToPubsubTopic(contentTopic, clusterId = DEFAULT_CLUSTER_ID, networkShards = 8) {
    if (!contentTopic) {
        throw Error("Content topic must be specified");
    }
    const shardIndex = contentTopicToShardIndex(contentTopic, networkShards);
    return `/waku/2/rs/${clusterId}/${shardIndex}`;
}
/**
 * Used when creating encoders/decoders to determine which pubsub topic to use
 */
function determinePubsubTopic(contentTopic, 
// TODO: make it accept ShardInfo https://github.com/waku-org/js-waku/issues/2086
pubsubTopicShardInfo) {
    if (typeof pubsubTopicShardInfo == "string") {
        return pubsubTopicShardInfo;
    }
    return pubsubTopicShardInfo?.shard !== undefined
        ? singleShardInfoToPubsubTopic(pubsubTopicShardInfo)
        : contentTopicToPubsubTopic(contentTopic, pubsubTopicShardInfo?.clusterId ?? DEFAULT_CLUSTER_ID);
}

const log = new Logger("message:version-0");
const OneMillion = BigInt(1_000_000);
const Version = 0;
class DecodedMessage {
    pubsubTopic;
    proto;
    constructor(pubsubTopic, proto) {
        this.pubsubTopic = pubsubTopic;
        this.proto = proto;
    }
    get ephemeral() {
        return Boolean(this.proto.ephemeral);
    }
    get payload() {
        return this.proto.payload;
    }
    get contentTopic() {
        return this.proto.contentTopic;
    }
    get _rawTimestamp() {
        return this.proto.timestamp;
    }
    get timestamp() {
        // In the case we receive a value that is bigger than JS's max number,
        // we catch the error and return undefined.
        try {
            if (this.proto.timestamp) {
                // nanoseconds 10^-9 to milliseconds 10^-3
                const timestamp = this.proto.timestamp / OneMillion;
                return new Date(Number(timestamp));
            }
            return;
        }
        catch (e) {
            return;
        }
    }
    get meta() {
        return this.proto.meta;
    }
    get version() {
        // https://rfc.vac.dev/spec/14/
        // > If omitted, the value SHOULD be interpreted as version 0.
        return this.proto.version ?? 0;
    }
    get rateLimitProof() {
        return this.proto.rateLimitProof;
    }
}
class Encoder {
    contentTopic;
    ephemeral;
    pubsubTopic;
    metaSetter;
    constructor(contentTopic, ephemeral = false, pubsubTopic, metaSetter) {
        this.contentTopic = contentTopic;
        this.ephemeral = ephemeral;
        this.pubsubTopic = pubsubTopic;
        this.metaSetter = metaSetter;
        if (!contentTopic || contentTopic === "") {
            throw new Error("Content topic must be specified");
        }
    }
    async toWire(message$1) {
        return WakuMessage$4.encode(await this.toProtoObj(message$1));
    }
    async toProtoObj(message) {
        const timestamp = message.timestamp ?? new Date();
        const protoMessage = {
            payload: message.payload,
            version: Version,
            contentTopic: this.contentTopic,
            timestamp: BigInt(timestamp.valueOf()) * OneMillion,
            meta: undefined,
            rateLimitProof: message.rateLimitProof,
            ephemeral: this.ephemeral
        };
        if (this.metaSetter) {
            const meta = this.metaSetter(protoMessage);
            return { ...protoMessage, meta };
        }
        return protoMessage;
    }
}
/**
 * Creates an encoder that encode messages without Waku level encryption or signature.
 *
 * An encoder is used to encode messages in the [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/)
 * format to be sent over the Waku network. The resulting encoder can then be
 * pass to { @link @waku/interfaces!ISender.send } to automatically encode outgoing
 * messages.
 */
function createEncoder({ pubsubTopic, pubsubTopicShardInfo, contentTopic, ephemeral, metaSetter }) {
    return new Encoder(contentTopic, ephemeral, determinePubsubTopic(contentTopic, pubsubTopic ?? pubsubTopicShardInfo), metaSetter);
}
class Decoder {
    pubsubTopic;
    contentTopic;
    constructor(pubsubTopic, contentTopic) {
        this.pubsubTopic = pubsubTopic;
        this.contentTopic = contentTopic;
        if (!contentTopic || contentTopic === "") {
            throw new Error("Content topic must be specified");
        }
    }
    fromWireToProtoObj(bytes) {
        const protoMessage = WakuMessage$4.decode(bytes);
        return Promise.resolve({
            payload: protoMessage.payload,
            contentTopic: protoMessage.contentTopic,
            version: protoMessage.version ?? undefined,
            timestamp: protoMessage.timestamp ?? undefined,
            meta: protoMessage.meta ?? undefined,
            rateLimitProof: protoMessage.rateLimitProof ?? undefined,
            ephemeral: protoMessage.ephemeral ?? false
        });
    }
    async fromProtoObj(pubsubTopic, proto) {
        // https://rfc.vac.dev/spec/14/
        // > If omitted, the value SHOULD be interpreted as version 0.
        if (proto.version ?? 0 !== Version) {
            log.error("Failed to decode due to incorrect version, expected:", Version, ", actual:", proto.version);
            return Promise.resolve(undefined);
        }
        return new DecodedMessage(pubsubTopic, proto);
    }
}
/**
 * Creates a decoder that decode messages without Waku level encryption.
 *
 * A decoder is used to decode messages from the [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/)
 * format when received from the Waku network. The resulting decoder can then be
 * pass to { @link @waku/interfaces!IReceiver.subscribe } to automatically decode incoming
 * messages.
 *
 * @param contentTopic The resulting decoder will only decode messages with this content topic.
 */
function createDecoder(contentTopic, pubsubTopicShardInfo) {
    return new Decoder(determinePubsubTopic(contentTopic, pubsubTopicShardInfo), contentTopic);
}

var version_0 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DecodedMessage: DecodedMessage,
    Decoder: Decoder,
    Encoder: Encoder,
    Version: Version,
    createDecoder: createDecoder,
    createEncoder: createEncoder,
    proto: message
});

export { DecodedMessage as D, Encoder as E, FilterSubscribeRequest as F, MessagePush as M, PushRpc$1 as P, StoreQueryRequest$1 as S, Version as V, WakuMetadataRequest as W, encode as a, FilterSubscribeResponse$1 as b, PushResponse as c, decode as d, encodingLength as e, StoreQueryResponse$1 as f, createEncoder as g, pubsubTopicsToShardInfo as h, WakuMetadataResponse as i, createDecoder as j, Decoder as k, message as m, pubsubTopicToSingleShardInfo as p, shardInfoToPubsubTopics as s, version_0 as v };

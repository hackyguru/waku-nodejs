import { getPeersForProtocol, sortPeersByLatency } from "@waku/utils/libp2p";
import { filterPeersByDiscovery } from "./filterPeers.js";
import { StreamManager } from "./stream_manager/index.js";
/**
 * A class with predefined helpers, to be used as a base to implement Waku
 * Protocols.
 */
export class BaseProtocol {
    multicodec;
    components;
    log;
    pubsubTopics;
    addLibp2pEventListener;
    removeLibp2pEventListener;
    streamManager;
    constructor(multicodec, components, log, pubsubTopics) {
        this.multicodec = multicodec;
        this.components = components;
        this.log = log;
        this.pubsubTopics = pubsubTopics;
        this.addLibp2pEventListener = components.events.addEventListener.bind(components.events);
        this.removeLibp2pEventListener = components.events.removeEventListener.bind(components.events);
        this.streamManager = new StreamManager(multicodec, components.connectionManager.getConnections.bind(components.connectionManager), this.addLibp2pEventListener);
    }
    async getStream(peer) {
        return this.streamManager.getStream(peer);
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * the class protocol. Waku may or may not be currently connected to these
     * peers.
     */
    async allPeers() {
        return getPeersForProtocol(this.components.peerStore, [this.multicodec]);
    }
    async connectedPeers() {
        const peers = await this.allPeers();
        return peers.filter((peer) => {
            const connections = this.components.connectionManager.getConnections(peer.id);
            return connections.length > 0;
        });
    }
    /**
     * Retrieves a list of connected peers that support the protocol. The list is sorted by latency.
     *
     * @param numPeers - The total number of peers to retrieve. If 0, all peers are returned.
     * @param maxBootstrapPeers - The maximum number of bootstrap peers to retrieve.
     * @returns A list of peers that support the protocol sorted by latency. By default, returns all peers available, including bootstrap.
     */
    async getPeers({ numPeers, maxBootstrapPeers } = {
        maxBootstrapPeers: 0,
        numPeers: 0
    }) {
        // Retrieve all connected peers that support the protocol & shard (if configured)
        const allAvailableConnectedPeers = await this.connectedPeers();
        // Filter the peers based on discovery & number of peers requested
        const filteredPeers = filterPeersByDiscovery(allAvailableConnectedPeers, numPeers, maxBootstrapPeers);
        // Sort the peers by latency
        const sortedFilteredPeers = await sortPeersByLatency(this.components.peerStore, filteredPeers);
        if (sortedFilteredPeers.length === 0) {
            this.log.warn("No peers found. Ensure you have a connection to the network.");
        }
        if (sortedFilteredPeers.length < numPeers) {
            this.log.warn(`Only ${sortedFilteredPeers.length} peers found. Requested ${numPeers}.`);
        }
        return sortedFilteredPeers;
    }
}
//# sourceMappingURL=base_protocol.js.map
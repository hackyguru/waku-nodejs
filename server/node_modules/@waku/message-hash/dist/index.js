import { sha256 } from "@noble/hashes/sha256";
import { isDefined } from "@waku/utils";
import { bytesToHex, concat, numberToBytes, utf8ToBytes } from "@waku/utils/bytes";
/**
 * Deterministic Message Hashing as defined in
 * [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/#deterministic-message-hashing)
 */
export function messageHash(pubsubTopic, message) {
    const pubsubTopicBytes = utf8ToBytes(pubsubTopic);
    const contentTopicBytes = utf8ToBytes(message.contentTopic);
    const timestampBytes = tryConvertTimestampToBytes(message.timestamp);
    const bytes = concat([
        pubsubTopicBytes,
        message.payload,
        contentTopicBytes,
        message.meta,
        timestampBytes
    ].filter(isDefined));
    return sha256(bytes);
}
function tryConvertTimestampToBytes(timestamp) {
    if (!timestamp) {
        return;
    }
    let bigIntTimestamp;
    if (typeof timestamp === "bigint") {
        bigIntTimestamp = timestamp;
    }
    else {
        bigIntTimestamp = BigInt(timestamp.valueOf()) * 1000000n;
    }
    return numberToBytes(bigIntTimestamp);
}
export function messageHashStr(pubsubTopic, message) {
    const hash = messageHash(pubsubTopic, message);
    const hashStr = bytesToHex(hash);
    return hashStr;
}
//# sourceMappingURL=index.js.map
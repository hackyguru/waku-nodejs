import type { Peer } from "@libp2p/interface";
import type { PeerId } from "@libp2p/interface";
import { ConnectionManager, FilterCore } from "@waku/core";
import { type Callback, type ContentTopic, type IDecodedMessage, type IDecoder, type ILightPush, type ISubscription, type Libp2p, type PeerIdStr, type PubsubTopic, type SDKProtocolResult, type SubscribeOptions } from "@waku/interfaces";
import { WakuMessage } from "@waku/proto";
export declare class SubscriptionManager implements ISubscription {
    private readonly pubsubTopic;
    private readonly protocol;
    private readonly connectionManager;
    private readonly getPeers;
    private readonly renewPeer;
    private readonly libp2p;
    private readonly lightPush?;
    private reliabilityMonitor;
    private keepAliveTimeout;
    private keepAliveInterval;
    private enableLightPushFilterCheck;
    private subscriptionCallbacks;
    constructor(pubsubTopic: PubsubTopic, protocol: FilterCore, connectionManager: ConnectionManager, getPeers: () => Peer[], renewPeer: (peerToDisconnect: PeerId) => Promise<Peer | undefined>, libp2p: Libp2p, lightPush?: ILightPush | undefined);
    subscribe<T extends IDecodedMessage>(decoders: IDecoder<T> | IDecoder<T>[], callback: Callback<T>, options?: SubscribeOptions): Promise<SDKProtocolResult>;
    unsubscribe(contentTopics: ContentTopic[]): Promise<SDKProtocolResult>;
    ping(peerId?: PeerId): Promise<SDKProtocolResult>;
    unsubscribeAll(): Promise<SDKProtocolResult>;
    processIncomingMessage(message: WakuMessage, peerIdStr: PeerIdStr): Promise<void>;
    private subscribeWithPeerVerification;
    private handleResult;
    private pingSpecificPeer;
    private startSubscriptionsMaintenance;
    private stopSubscriptionsMaintenance;
    private startConnectionListener;
    private stopConnectionListener;
    private connectionListener;
    private startKeepAlivePings;
    private stopKeepAlivePings;
    private sendLightPushCheckMessage;
    private buildLightPushContentTopic;
}

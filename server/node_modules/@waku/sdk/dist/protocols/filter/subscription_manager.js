import { createDecoder, createEncoder } from "@waku/core";
import { EConnectionStateEvents, ProtocolError } from "@waku/interfaces";
import { groupByContentTopic, Logger } from "@waku/utils";
import { ReliabilityMonitorManager } from "../../reliability_monitor/index.js";
import { DEFAULT_KEEP_ALIVE, DEFAULT_LIGHT_PUSH_FILTER_CHECK, DEFAULT_LIGHT_PUSH_FILTER_CHECK_INTERVAL, DEFAULT_SUBSCRIBE_OPTIONS } from "./constants.js";
const log = new Logger("sdk:filter:subscription_manager");
export class SubscriptionManager {
    pubsubTopic;
    protocol;
    connectionManager;
    getPeers;
    renewPeer;
    libp2p;
    lightPush;
    reliabilityMonitor;
    keepAliveTimeout = DEFAULT_KEEP_ALIVE;
    keepAliveInterval = null;
    enableLightPushFilterCheck = DEFAULT_LIGHT_PUSH_FILTER_CHECK;
    subscriptionCallbacks;
    constructor(pubsubTopic, protocol, connectionManager, getPeers, renewPeer, libp2p, lightPush) {
        this.pubsubTopic = pubsubTopic;
        this.protocol = protocol;
        this.connectionManager = connectionManager;
        this.getPeers = getPeers;
        this.renewPeer = renewPeer;
        this.libp2p = libp2p;
        this.lightPush = lightPush;
        this.pubsubTopic = pubsubTopic;
        this.subscriptionCallbacks = new Map();
        this.reliabilityMonitor = ReliabilityMonitorManager.createReceiverMonitor(this.pubsubTopic, this.getPeers.bind(this), this.renewPeer.bind(this), () => Array.from(this.subscriptionCallbacks.keys()), this.protocol.subscribe.bind(this.protocol), this.protocol.addLibp2pEventListener.bind(this.protocol), this.sendLightPushCheckMessage.bind(this));
    }
    async subscribe(decoders, callback, options = DEFAULT_SUBSCRIBE_OPTIONS) {
        this.reliabilityMonitor.setMaxPingFailures(options.pingsBeforePeerRenewed);
        this.keepAliveTimeout = options.keepAlive || DEFAULT_KEEP_ALIVE;
        this.enableLightPushFilterCheck =
            options?.enableLightPushFilterCheck || DEFAULT_LIGHT_PUSH_FILTER_CHECK;
        const decodersArray = Array.isArray(decoders) ? decoders : [decoders];
        // check that all decoders are configured for the same pubsub topic as this subscription
        for (const decoder of decodersArray) {
            if (decoder.pubsubTopic !== this.pubsubTopic) {
                return {
                    failures: [
                        {
                            error: ProtocolError.TOPIC_DECODER_MISMATCH
                        }
                    ],
                    successes: []
                };
            }
        }
        if (this.enableLightPushFilterCheck) {
            decodersArray.push(createDecoder(this.buildLightPushContentTopic(), this.pubsubTopic));
        }
        const decodersGroupedByCT = groupByContentTopic(decodersArray);
        const contentTopics = Array.from(decodersGroupedByCT.keys());
        const promises = this.getPeers().map(async (peer) => this.subscribeWithPeerVerification(peer, contentTopics));
        const results = await Promise.allSettled(promises);
        const finalResult = this.handleResult(results, "subscribe");
        // Save the callback functions by content topics so they
        // can easily be removed (reciprocally replaced) if `unsubscribe` (reciprocally `subscribe`)
        // is called for those content topics
        decodersGroupedByCT.forEach((decoders, contentTopic) => {
            // Cast the type because a given `subscriptionCallbacks` map may hold
            // Decoder that decode to different implementations of `IDecodedMessage`
            const subscriptionCallback = {
                decoders,
                callback
            };
            // don't handle case of internal content topic
            if (contentTopic === this.buildLightPushContentTopic()) {
                return;
            }
            // The callback and decoder may override previous values, this is on
            // purpose as the user may call `subscribe` to refresh the subscription
            this.subscriptionCallbacks.set(contentTopic, subscriptionCallback);
        });
        this.startSubscriptionsMaintenance(this.keepAliveTimeout);
        return finalResult;
    }
    async unsubscribe(contentTopics) {
        const promises = this.getPeers().map(async (peer) => {
            const response = await this.protocol.unsubscribe(this.pubsubTopic, peer, contentTopics);
            contentTopics.forEach((contentTopic) => {
                this.subscriptionCallbacks.delete(contentTopic);
            });
            return response;
        });
        const results = await Promise.allSettled(promises);
        const finalResult = this.handleResult(results, "unsubscribe");
        if (this.subscriptionCallbacks.size === 0) {
            this.stopSubscriptionsMaintenance();
        }
        return finalResult;
    }
    async ping(peerId) {
        log.info("Sending keep-alive ping");
        const peers = peerId ? [peerId] : this.getPeers().map((peer) => peer.id);
        const promises = peers.map((peerId) => this.pingSpecificPeer(peerId));
        const results = await Promise.allSettled(promises);
        return this.handleResult(results, "ping");
    }
    async unsubscribeAll() {
        const promises = this.getPeers().map(async (peer) => this.protocol.unsubscribeAll(this.pubsubTopic, peer));
        const results = await Promise.allSettled(promises);
        this.subscriptionCallbacks.clear();
        const finalResult = this.handleResult(results, "unsubscribeAll");
        this.stopSubscriptionsMaintenance();
        return finalResult;
    }
    async processIncomingMessage(message, peerIdStr) {
        const alreadyReceived = this.reliabilityMonitor.notifyMessageReceived(peerIdStr, message);
        if (alreadyReceived) {
            log.info("Message already received, skipping");
            return;
        }
        const { contentTopic } = message;
        const subscriptionCallback = this.subscriptionCallbacks.get(contentTopic);
        if (!subscriptionCallback) {
            log.error("No subscription callback available for ", contentTopic);
            return;
        }
        log.info("Processing message with content topic ", contentTopic, " on pubsub topic ", this.pubsubTopic);
        await pushMessage(subscriptionCallback, this.pubsubTopic, message);
    }
    async subscribeWithPeerVerification(peer, contentTopics) {
        const result = await this.protocol.subscribe(this.pubsubTopic, peer, contentTopics);
        await this.sendLightPushCheckMessage(peer);
        return result;
    }
    handleResult(results, type) {
        const result = { failures: [], successes: [] };
        for (const promiseResult of results) {
            if (promiseResult.status === "rejected") {
                log.error(`Failed to resolve ${type} promise successfully: `, promiseResult.reason);
                result.failures.push({ error: ProtocolError.GENERIC_FAIL });
            }
            else {
                const coreResult = promiseResult.value;
                if (coreResult.failure) {
                    result.failures.push(coreResult.failure);
                }
                else {
                    result.successes.push(coreResult.success);
                }
            }
        }
        return result;
    }
    async pingSpecificPeer(peerId) {
        const peer = this.getPeers().find((p) => p.id.equals(peerId));
        if (!peer) {
            return {
                success: null,
                failure: {
                    peerId,
                    error: ProtocolError.NO_PEER_AVAILABLE
                }
            };
        }
        let result;
        try {
            result = await this.protocol.ping(peer);
        }
        catch (error) {
            result = {
                success: null,
                failure: {
                    peerId,
                    error: ProtocolError.GENERIC_FAIL
                }
            };
        }
        log.info(`Received result from filter ping peerId:${peerId.toString()}\tsuccess:${result.success?.toString()}\tfailure:${result.failure?.error}`);
        await this.reliabilityMonitor.handlePingResult(peerId, result);
        return result;
    }
    startSubscriptionsMaintenance(timeout) {
        log.info("Starting subscriptions maintenance");
        this.startKeepAlivePings(timeout);
        this.startConnectionListener();
    }
    stopSubscriptionsMaintenance() {
        log.info("Stopping subscriptions maintenance");
        this.stopKeepAlivePings();
        this.stopConnectionListener();
    }
    startConnectionListener() {
        this.connectionManager.addEventListener(EConnectionStateEvents.CONNECTION_STATUS, this.connectionListener.bind(this));
    }
    stopConnectionListener() {
        this.connectionManager.removeEventListener(EConnectionStateEvents.CONNECTION_STATUS, this.connectionListener.bind(this));
    }
    async connectionListener({ detail: isConnected }) {
        if (!isConnected) {
            this.stopKeepAlivePings();
            return;
        }
        try {
            // we do nothing here, as the renewal process is managed internally by `this.ping()`
            await this.ping();
        }
        catch (err) {
            log.error(`networkStateListener failed to recover: ${err}`);
        }
        this.startKeepAlivePings(this.keepAliveTimeout);
    }
    startKeepAlivePings(timeout) {
        if (this.keepAliveInterval) {
            log.info("Recurring pings already set up.");
            return;
        }
        this.keepAliveInterval = setInterval(() => {
            void this.ping();
        }, timeout);
    }
    stopKeepAlivePings() {
        if (!this.keepAliveInterval) {
            log.info("Already stopped recurring pings.");
            return;
        }
        log.info("Stopping recurring pings.");
        clearInterval(this.keepAliveInterval);
        this.keepAliveInterval = null;
    }
    async sendLightPushCheckMessage(peer) {
        if (this.lightPush &&
            this.libp2p &&
            this.reliabilityMonitor.shouldVerifyPeer(peer.id)) {
            const encoder = createEncoder({
                contentTopic: this.buildLightPushContentTopic(),
                pubsubTopic: this.pubsubTopic,
                ephemeral: true
            });
            const message = { payload: new Uint8Array(1) };
            const protoMessage = await encoder.toProtoObj(message);
            // make a delay to be sure message is send when subscription is in place
            setTimeout((async () => {
                const result = await this.lightPush.protocol.send(encoder, message, peer);
                this.reliabilityMonitor.notifyMessageSent(peer.id, protoMessage);
                if (result.failure) {
                    log.error(`failed to send lightPush ping message to peer:${peer.id.toString()}\t${result.failure.error}`);
                    return;
                }
            }), DEFAULT_LIGHT_PUSH_FILTER_CHECK_INTERVAL);
        }
    }
    buildLightPushContentTopic() {
        return `/js-waku-subscription-ping/1/${this.libp2p.peerId.toString()}/utf8`;
    }
}
async function pushMessage(subscriptionCallback, pubsubTopic, message) {
    const { decoders, callback } = subscriptionCallback;
    const { contentTopic } = message;
    if (!contentTopic) {
        log.warn("Message has no content topic, skipping");
        return;
    }
    try {
        const decodePromises = decoders.map((dec) => dec
            .fromProtoObj(pubsubTopic, message)
            .then((decoded) => decoded || Promise.reject("Decoding failed")));
        const decodedMessage = await Promise.any(decodePromises);
        await callback(decodedMessage);
    }
    catch (e) {
        log.error("Error decoding message", e);
    }
}
//# sourceMappingURL=subscription_manager.js.map
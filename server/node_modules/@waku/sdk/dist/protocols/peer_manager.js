import { getHealthManager } from "@waku/core";
import { Mutex } from "async-mutex";
export class PeerManager {
    connectionManager;
    core;
    log;
    peers = new Map();
    healthManager;
    readMutex = new Mutex();
    writeMutex = new Mutex();
    writeLockHolder = null;
    constructor(connectionManager, core, log) {
        this.connectionManager = connectionManager;
        this.core = core;
        this.log = log;
        this.healthManager = getHealthManager();
        this.healthManager.updateProtocolHealth(this.core.multicodec, 0);
    }
    getWriteLockHolder() {
        return this.writeLockHolder;
    }
    getPeers() {
        return Array.from(this.peers.values());
    }
    async addPeer(peer) {
        return this.writeMutex.runExclusive(async () => {
            this.writeLockHolder = `addPeer: ${peer.id.toString()}`;
            await this.connectionManager.attemptDial(peer.id);
            this.peers.set(peer.id.toString(), peer);
            this.log.info(`Added and dialed peer: ${peer.id.toString()}`);
            this.healthManager.updateProtocolHealth(this.core.multicodec, this.peers.size);
            this.writeLockHolder = null;
        });
    }
    async removePeer(peerId) {
        return this.writeMutex.runExclusive(() => {
            this.writeLockHolder = `removePeer: ${peerId.toString()}`;
            this.peers.delete(peerId.toString());
            this.log.info(`Removed peer: ${peerId.toString()}`);
            this.healthManager.updateProtocolHealth(this.core.multicodec, this.peers.size);
            this.writeLockHolder = null;
        });
    }
    async getPeerCount() {
        return this.readMutex.runExclusive(() => this.peers.size);
    }
    async hasPeers() {
        return this.readMutex.runExclusive(() => this.peers.size > 0);
    }
    async removeExcessPeers(excessPeers) {
        this.log.info(`Removing ${excessPeers} excess peer(s)`);
        const peersToRemove = Array.from(this.peers.values()).slice(0, excessPeers);
        for (const peer of peersToRemove) {
            await this.removePeer(peer.id);
        }
    }
    /**
     * Finds and adds new peers to the peers list.
     * @param numPeers The number of peers to find and add.
     */
    async findAndAddPeers(numPeers) {
        const additionalPeers = await this.findPeers(numPeers);
        if (additionalPeers.length === 0) {
            this.log.warn("No additional peers found");
            return [];
        }
        return this.addMultiplePeers(additionalPeers);
    }
    /**
     * Finds additional peers.
     * @param numPeers The number of peers to find.
     */
    async findPeers(numPeers) {
        const connectedPeers = await this.core.getPeers();
        return this.readMutex.runExclusive(async () => {
            const newPeers = connectedPeers
                .filter((peer) => !this.peers.has(peer.id.toString()))
                .slice(0, numPeers);
            return newPeers;
        });
    }
    async addMultiplePeers(peers) {
        const addedPeers = [];
        for (const peer of peers) {
            await this.addPeer(peer);
            addedPeers.push(peer);
        }
        return addedPeers;
    }
}
//# sourceMappingURL=peer_manager.js.map
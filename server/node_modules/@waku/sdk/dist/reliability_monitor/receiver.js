import { messageHashStr } from "@waku/message-hash";
import { Logger } from "@waku/utils";
import { bytesToUtf8 } from "@waku/utils/bytes";
const log = new Logger("sdk:receiver:reliability_monitor");
const DEFAULT_MAX_PINGS = 3;
const MESSAGE_VERIFICATION_DELAY = 5_000;
export class ReceiverReliabilityMonitor {
    pubsubTopic;
    getPeers;
    renewPeer;
    getContentTopics;
    protocolSubscribe;
    addLibp2pEventListener;
    sendLightPushMessage;
    receivedMessagesFormPeer = new Set();
    receivedMessages = new Set();
    scheduledVerification = new Map();
    verifiedPeers = new Set();
    peerFailures = new Map();
    maxPingFailures = DEFAULT_MAX_PINGS;
    peerRenewalLocks = new Set();
    constructor(pubsubTopic, getPeers, renewPeer, getContentTopics, protocolSubscribe, addLibp2pEventListener, sendLightPushMessage) {
        this.pubsubTopic = pubsubTopic;
        this.getPeers = getPeers;
        this.renewPeer = renewPeer;
        this.getContentTopics = getContentTopics;
        this.protocolSubscribe = protocolSubscribe;
        this.addLibp2pEventListener = addLibp2pEventListener;
        this.sendLightPushMessage = sendLightPushMessage;
        this.addLibp2pEventListener("peer:disconnect", (evt) => {
            const peerId = evt.detail;
            if (this.getPeers().some((p) => p.id.equals(peerId))) {
                void this.renewAndSubscribePeer(peerId);
            }
        });
    }
    setMaxPingFailures(value) {
        if (value === undefined) {
            return;
        }
        this.maxPingFailures = value;
    }
    async handlePingResult(peerId, result) {
        if (result?.success) {
            this.peerFailures.delete(peerId.toString());
            return;
        }
        const failures = (this.peerFailures.get(peerId.toString()) || 0) + 1;
        this.peerFailures.set(peerId.toString(), failures);
        if (failures >= this.maxPingFailures) {
            try {
                log.info(`Attempting to renew ${peerId.toString()} due to ping failures.`);
                await this.renewAndSubscribePeer(peerId);
                this.peerFailures.delete(peerId.toString());
            }
            catch (error) {
                log.error(`Failed to renew peer ${peerId.toString()}: ${error}.`);
            }
        }
    }
    notifyMessageReceived(peerIdStr, message) {
        const hash = this.buildMessageHash(message);
        this.verifiedPeers.add(peerIdStr);
        this.receivedMessagesFormPeer.add(`${peerIdStr}-${hash}`);
        log.info(`notifyMessage received debug: ephemeral:${message.ephemeral}\t${bytesToUtf8(message.payload)}`);
        log.info(`notifyMessage received: peer:${peerIdStr}\tmessage:${hash}`);
        if (this.receivedMessages.has(hash)) {
            return true;
        }
        this.receivedMessages.add(hash);
        return false;
    }
    notifyMessageSent(peerId, message) {
        const peerIdStr = peerId.toString();
        const hash = this.buildMessageHash(message);
        log.info(`notifyMessage sent debug: ${bytesToUtf8(message.payload)}`);
        if (this.scheduledVerification.has(peerIdStr)) {
            log.warn(`notifyMessage sent: attempting to schedule verification for pending peer:${peerIdStr}\tmessage:${hash}`);
            return;
        }
        const timeout = window.setTimeout((async () => {
            const receivedAnyMessage = this.verifiedPeers.has(peerIdStr);
            const receivedTestMessage = this.receivedMessagesFormPeer.has(`${peerIdStr}-${hash}`);
            if (receivedAnyMessage || receivedTestMessage) {
                log.info(`notifyMessage sent setTimeout: verified that peer pushes filter messages, peer:${peerIdStr}\tmessage:${hash}`);
                return;
            }
            log.warn(`notifyMessage sent setTimeout: peer didn't return probe message, attempting renewAndSubscribe, peer:${peerIdStr}\tmessage:${hash}`);
            this.scheduledVerification.delete(peerIdStr);
            await this.renewAndSubscribePeer(peerId);
        }), MESSAGE_VERIFICATION_DELAY);
        this.scheduledVerification.set(peerIdStr, timeout);
    }
    shouldVerifyPeer(peerId) {
        const peerIdStr = peerId.toString();
        const isPeerVerified = this.verifiedPeers.has(peerIdStr);
        const isVerificationPending = this.scheduledVerification.has(peerIdStr);
        return !(isPeerVerified || isVerificationPending);
    }
    buildMessageHash(message) {
        return messageHashStr(this.pubsubTopic, message);
    }
    async renewAndSubscribePeer(peerId) {
        const peerIdStr = peerId.toString();
        try {
            if (this.peerRenewalLocks.has(peerIdStr)) {
                log.info(`Peer ${peerIdStr} is already being renewed.`);
                return;
            }
            this.peerRenewalLocks.add(peerIdStr);
            const newPeer = await this.renewPeer(peerId);
            if (!newPeer) {
                log.warn(`Failed to renew peer ${peerIdStr}: No new peer found.`);
                return;
            }
            await this.protocolSubscribe(this.pubsubTopic, newPeer, this.getContentTopics());
            await this.sendLightPushMessage(newPeer);
            this.peerFailures.delete(peerIdStr);
            return newPeer;
        }
        catch (error) {
            log.error(`Failed to renew peer ${peerIdStr}: ${error}.`);
            return;
        }
        finally {
            this.peerRenewalLocks.delete(peerIdStr);
        }
    }
}
//# sourceMappingURL=receiver.js.map
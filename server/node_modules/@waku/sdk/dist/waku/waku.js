import { isPeerId } from "@libp2p/interface";
import { multiaddr } from "@multiformats/multiaddr";
import { ConnectionManager, getHealthManager } from "@waku/core";
import { Protocols } from "@waku/interfaces";
import { Logger } from "@waku/utils";
import { wakuFilter } from "../protocols/filter/index.js";
import { wakuLightPush } from "../protocols/light_push/index.js";
import { wakuStore } from "../protocols/store/index.js";
import { ReliabilityMonitorManager } from "../reliability_monitor/index.js";
import { waitForRemotePeer } from "./wait_for_remote_peer.js";
export const DefaultPingKeepAliveValueSecs = 5 * 60;
export const DefaultRelayKeepAliveValueSecs = 5 * 60;
export const DefaultUserAgent = "js-waku";
export const DefaultPingMaxInboundStreams = 10;
const log = new Logger("waku");
export class WakuNode {
    pubsubTopics;
    libp2p;
    relay;
    store;
    filter;
    lightPush;
    connectionManager;
    health;
    constructor(pubsubTopics, options, libp2p, protocolsEnabled, relay) {
        this.pubsubTopics = pubsubTopics;
        this.relay = relay;
        this.libp2p = libp2p;
        protocolsEnabled = {
            filter: false,
            lightpush: false,
            store: false,
            ...protocolsEnabled
        };
        const pingKeepAlive = options.pingKeepAlive || DefaultPingKeepAliveValueSecs;
        const relayKeepAlive = this.relay
            ? options.relayKeepAlive || DefaultRelayKeepAliveValueSecs
            : 0;
        const peerId = this.libp2p.peerId.toString();
        this.connectionManager = ConnectionManager.create(peerId, libp2p, { pingKeepAlive, relayKeepAlive }, this.pubsubTopics, this.relay);
        this.health = getHealthManager();
        if (protocolsEnabled.store) {
            const store = wakuStore(this.connectionManager);
            this.store = store(libp2p);
        }
        if (protocolsEnabled.lightpush) {
            const lightPush = wakuLightPush(this.connectionManager, options);
            this.lightPush = lightPush(libp2p);
        }
        if (protocolsEnabled.filter) {
            const filter = wakuFilter(this.connectionManager, this.lightPush, options);
            this.filter = filter(libp2p);
        }
        log.info("Waku node created", peerId, `relay: ${!!this.relay}, store: ${!!this.store}, light push: ${!!this
            .lightPush}, filter: ${!!this.filter}`);
    }
    get peerId() {
        return this.libp2p.peerId;
    }
    get protocols() {
        return this.libp2p.getProtocols();
    }
    async dial(peer, protocols) {
        const _protocols = protocols ?? [];
        const peerId = this.mapToPeerIdOrMultiaddr(peer);
        if (typeof protocols === "undefined") {
            this.relay && _protocols.push(Protocols.Relay);
            this.store && _protocols.push(Protocols.Store);
            this.filter && _protocols.push(Protocols.Filter);
            this.lightPush && _protocols.push(Protocols.LightPush);
        }
        const codecs = [];
        if (_protocols.includes(Protocols.Relay)) {
            if (this.relay) {
                this.relay.gossipSub.multicodecs.forEach((codec) => codecs.push(codec));
            }
            else {
                log.error("Relay codec not included in dial codec: protocol not mounted locally");
            }
        }
        if (_protocols.includes(Protocols.Store)) {
            if (this.store) {
                codecs.push(this.store.protocol.multicodec);
            }
            else {
                log.error("Store codec not included in dial codec: protocol not mounted locally");
            }
        }
        if (_protocols.includes(Protocols.LightPush)) {
            if (this.lightPush) {
                codecs.push(this.lightPush.protocol.multicodec);
            }
            else {
                log.error("Light Push codec not included in dial codec: protocol not mounted locally");
            }
        }
        if (_protocols.includes(Protocols.Filter)) {
            if (this.filter) {
                codecs.push(this.filter.protocol.multicodec);
            }
            else {
                log.error("Filter codec not included in dial codec: protocol not mounted locally");
            }
        }
        log.info(`Dialing to ${peerId.toString()} with protocols ${_protocols}`);
        return this.libp2p.dialProtocol(peerId, codecs);
    }
    async start() {
        await this.libp2p.start();
    }
    async stop() {
        ReliabilityMonitorManager.stopAll();
        this.connectionManager.stop();
        await this.libp2p.stop();
    }
    async waitForPeers(protocols, timeoutMs) {
        return waitForRemotePeer(this, protocols, timeoutMs);
    }
    isStarted() {
        return this.libp2p.status == "started";
    }
    isConnected() {
        return this.connectionManager.isConnected();
    }
    mapToPeerIdOrMultiaddr(peerId) {
        return isPeerId(peerId) ? peerId : multiaddr(peerId);
    }
}
//# sourceMappingURL=waku.js.map